# OldDriver

[题目地址](https://adworld.xctf.org.cn/challenges/details?hash=3d1caf9f-20d5-479d-956a-e2e0be7c43ee_2)

RSA，Crypto中的拦路虎。很好这道题我完全不会，背后的数学原理基本也是一知半解。所以这里我会解释别人的攻击脚本。

附件发现了几组e，n，c，看到这三个字母基本可以判定是RSA了。一般来说e都是选择65535，这里只有10，说明可能要从这里入手。

网上可以搜到是低加密指数广播攻击。新名词，来看看是啥。

- ### 低加密指数广播攻击
- > 出现于：e值过小，加密的明文每次都相同，使用的n每次都不同。通常会给和e值相同数量组的数据。广播就代表将同样的明文加密多次但使用不同的n。
- > 原理：由RSA加密方法可得 c=m^e mod n ,那么此时我们获得了i组c和i组n。把m^e看成一个整体，再用中国剩余定理可列出同余方程组，其解就是m^e，再将m开e次方就是我们要的flag。

先把别人的writeup贴出来再慢慢讲，毕竟我也不是很会(･･;)

```python
import gmpy2
from functools import reduce
from Crypto.Util.number import long_to_bytes


# 中国剩余定理
def CRT(cipher, n):
    N = reduce(lambda x, y: x * y, (i for i in n))
    result = 0
    data = zip(cipher, n)
    for ci, ni in data:
        Ni = N // ni
        di = gmpy2.invert(Ni, ni)
        result += ci * Ni * di
    return result % N, N


# 读入 e, n, c
e = 10

c = [
    7366067574741171461722065133242916080495505913663250330082747465383676893970411476550748394841437418105312353971095003424322679616940371123028982189502042,
    21962825323300469151795920289886886562790942771546858500842179806566435767103803978885148772139305484319688249368999503784441507383476095946258011317951461,
    6569689420274066957835983390583585286570087619048110141187700584193792695235405077811544355169290382357149374107076406086154103351897890793598997687053983,
    4508246168044513518452493882713536390636741541551805821790338973797615971271867248584379813114125478195284692695928668946553625483179633266057122967547052,
    22966105670291282335588843018244161552764486373117942865966904076191122337435542553276743938817686729554714315494818922753880198945897222422137268427611672,
    17963313063405045742968136916219838352135561785389534381262979264585397896844470879023686508540355160998533122970239261072020689217153126649390825646712087,
    1652417534709029450380570653973705320986117679597563873022683140800507482560482948310131540948227797045505390333146191586749269249548168247316404074014639,
    15585771734488351039456631394040497759568679429510619219766191780807675361741859290490732451112648776648126779759368428205194684721516497026290981786239352,
    8965123421637694050044216844523379163347478029124815032832813225050732558524239660648746284884140746788823681886010577342254841014594570067467905682359797,
    13560945756543023008529388108446940847137853038437095244573035888531288577370829065666320069397898394848484847030321018915638381833935580958342719988978247]
n = [
    25162507052339714421839688873734596177751124036723831003300959761137811490715205742941738406548150240861779301784133652165908227917415483137585388986274803,
    23976859589904419798320812097681858652325473791891232710431997202897819580634937070900625213218095330766877190212418023297341732808839488308551126409983193,
    18503782836858540043974558035601654610948915505645219820150251062305120148745545906567548650191832090823482852604346478335353784501076761922605361848703623,
    23383087478545512218713157932934746110721706819077423418060220083657713428503582801909807142802647367994289775015595100541168367083097506193809451365010723,
    31775649089861428671057909076144152870796722528112580479442073365053916012507273433028451755436987054722496057749731758475958301164082755003195632005308493,
    22246342022943432820696190444155665289928378653841172632283227888174495402248633061010615572642126584591103750338919213945646074833823905521643025879053949,
    25395461142670631268156106136028325744393358436617528677967249347353524924655001151849544022201772500033280822372661344352607434738696051779095736547813043,
    32056508892744184901289413287728039891303832311548608141088227876326753674154124775132776928481935378184756756785107540781632570295330486738268173167809047,
    52849766269541827474228189428820648574162539595985395992261649809907435742263020551050064268890333392877173572811691599841253150460219986817964461970736553,
    30415984800307578932946399987559088968355638354344823359397204419191241802721772499486615661699080998502439901585573950889047918537906687840725005496238621]

x, N = CRT(c, n)

m = gmpy2.iroot(gmpy2.mpz(x), e)[0]

print(m)
print(long_to_bytes(m))
```

这个writeup是我在众多writeup里发现实现最简洁和巧妙的writeup之一。想要理解怎么实现的就要先了解所使用的函数。

- ### reduce()
- > 对参数序列中元素进行累积。函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。
- > 语法：reduce(function, iterable[, initializer])
- > 参数：function -- 有两个参数的函数  iterable -- 可迭代对象  initializer -- 可选，初始参数
- > 返回值：函数计算结果。

所以 N = reduce(lambda x, y: x * y, (i for i in n)) 这行代码先从n列表中取出两个值，也就是第一个和第二个，把结果作为下一次执行 function 的第一个参数，同时继续往下取值，也就是把n数组中的第三个值作为 function 的第二个参数，以此类推直到结束。你可能会有疑问，函数呢？ function 参数的实参值是什么？这里还要再介绍一个叫“匿名函数”的东西，也就是lambda。

- ### lambda
- > 是指一类无需定义标识符（函数名）的函数或子程序,通俗地说就是没有名字的函数。这是一种简单的、在同一行中定义函数的方法。
- > lambda 函数可以接收任意多个参数 (包括可选参数) 并且返回单个表达式的值。
- > lambda表达式只允许包含一个表达式，不能包含复杂语句，该表达式的运算结果就是函数的返回值。
- > 语法：lambda arg1,arg2,arg3… :<表达式>      arg1/arg2/arg3为函数的参数（函数输入），表达式相当于函数体，运算结果是表达式的运算结果。

所以 lambda x, y: x * y 相当于定义了一个函数，参数名为x和y，返回x和y的乘积。整个逻辑连起来看就是求n数组里所有元素的积。

- ### zip()
- > 将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象,可以使用 list() 将输出转换为列表。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同。
- > 语法：zip([iterable, ...])
- > 参数：iterabl -- 一个或多个迭代器

data = zip(cipher, n) 相当于密文和其对应的n的配对。列表形式就是\[(c1,n1),(c2,n2),(c3,n3)]……以此类推。for循环每次遍历一个元组，ci和ni的值分别为当前便利元组的c和n值。

- ### invert()
- > 求一个数的模逆元。
- > 语法：invert(x,y)
- > 参数：x -- 一个整数     y -- 如模逆元存在，模逆元是a对y的模逆元

我解释不清楚，这里再复习一下模逆元的概念好了。

- ### 模逆元
- > 也称为模倒数,一整数a对同余n之模逆元是指满足以下公式的整数 b: ab mod n=1

- ### 同余
- > 给定一个正整数m，如果两个整数a和b满足a-b能够被m整除，即(a-b)/m得到一个整数，那么就称整数a与b对模m同余，记作a≡b(mod m)。

放个[中国剩余定理](https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86)的链接，数学好的人可以看一下使用和证明。我们先把剩下的函数看完。

- ### iroot()
- > 将一个数开n次方
- 语法：iroot(x,n)
- 参数： x -- 要开方的数    n -- 要开的次方数

- ## mpz()
- > 初始化一个大整数x
- > 语法：mpz(x)
- > 参数： x -- 要初始化的大整数

这里 m = gmpy2.iroot(gmpy2.mpz(x), e)\[0] 取第一个索引的原因是此处返回的是mpz对象，第一个索引对应的是计算结果，第二个索引是布尔值。

我仍然不理解中国剩余定理和同余方程的解法。或许我会在未来补上的。

- ### Flag
- > flag{wo0_th3_tr4in_i5_leav1ng_g3t_on_it}