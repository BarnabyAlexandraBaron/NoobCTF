# reverse-box

[题目地址](https://adworld.xctf.org.cn/challenges/details?hash=bc4d9b7c-9e86-4435-8a0c-3e761ec333f3_2)

一眼就看出来……附件没给全。直接看[wp](https://blog.csdn.net/weixin_45055269/article/details/106201181)。wp给出的信息是让程序输出95eeaf95ef94234999582f722f492f72b19a7aaf72e6e776b57aee722fe77ab5ad9aaeb156729676ae7a236d99b1df4a，输出为这个的就是flag。

```c
undefined4 Main(int param_1,undefined4 *param_2)

{
  size_t sVar1;
  int in_GS_OFFSET;
  uint local_118;
  byte local_114 [256];
  int local_14;
  
  local_14 = *(int *)(in_GS_OFFSET + 0x14);
  if (param_1 < 2) {
    printf("usage: %s flag\n",*param_2);
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
  Encrypt(local_114);
  local_118 = 0;
  while( true ) {
    sVar1 = strlen((char *)param_2[1]);
    if (sVar1 <= local_118) break;
    printf("%02x",(uint)local_114[*(char *)(local_118 + param_2[1])]);
    local_118 = local_118 + 1;
  }
  putchar(10);
  if (local_14 != *(int *)(in_GS_OFFSET + 0x14)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}
```

[main函数的参数](https://www.codersrc.com/archives/9687.html)由三部分组成，分别是argc(int型，表示命令行参数的个数）、argv[\]（char数组型，指向命令行的每一个命令参数）、envp[\](char数组型，指向环境变量）。所以param[1]拿到的是第二个参数，就是我们的输入，param[0]是可执行文件名。根据期望输出的格式，找16进制输出在哪。printf函数将输入的每个字符当成索引取local_114数组的内容以16进制打印，说明local_114是一个表，这是个找对应的密码。Encrypt函数是逆向目标。

```c
void Encrypt(byte *param_1)

{
  byte bVar1;
  uint uVar2;
  byte local_12;
  byte local_11;
  
  uVar2 = time((time_t *)0x0);
  srand(uVar2);
  do {
    uVar2 = rand();
  } while ((uVar2 & 0xff) == 0);
  *param_1 = (byte)(uVar2 & 0xff);
  local_12 = 1;
  local_11 = 1;
  do {
    if ((char)local_12 < '\0') {
      bVar1 = 0x1b;
    }
    else {
      bVar1 = 0;
    }
    local_12 = bVar1 ^ local_12 * '\x02' ^ local_12;
    bVar1 = local_11 ^ local_11 * '\x02';
    bVar1 = bVar1 ^ bVar1 << 2;
    bVar1 = bVar1 ^ bVar1 << 4;
    if ((char)bVar1 < '\0') {
      local_11 = 9;
    }
    else {
      local_11 = 0;
    }
    local_11 = local_11 ^ bVar1;
    param_1[local_12] =
         *param_1 ^ local_11 ^ (bVar1 >> 7 | local_11 << 1) ^ (bVar1 >> 6 | local_11 << 2) ^
         (bVar1 >> 5 | local_11 << 3) ^ (bVar1 >> 4 | local_11 << 4);
  } while (local_12 != 1);
  return;
}
```

这什么玩意。分析一下一些关键信息，这个用作输出的表在输入不同参数时每次都是一样的吗？如果不是，我们完全可以自己输入个字符串，下断点拿出表，对应着把flag找回来就是了。跑几下发现是随机的，但是输入相同字符串得到的表是一样的。我们的目标转换为构造flag加密时的表。但是逆向简直裂开，这么多死亡位运算。

注意到`*param_1 = (byte)(uVar2 & 0xff);`，uVar2是随机数，按位与0xff作用为只取后两位，那可能性只有0-ff 256种情况，这么少直接爆破不就行了吗，uVar2对应在程序里是ebp-0xc，循环将其值设置为0-ff中的一个。剩下的问题在于找到爆破条件，用什么判断我们目前得到的表是对的呢？

再次体现出动调的重要性。在printf函数执行后下一个断点，发现printf执行后eax里存储的是打印出来的内容，这样就有爆破条件了，flag打印出来的第一个内容是0x95，我们只用看哪次爆破后eax里是0x95，当时用的表就是我们要找的表。至于怎么写脚本，今天才知道gdb是可以[写脚本](http://ifeve.com/gdb-script/)的。

```
set $i=0
set $total=256
while($i<$total)
  b *0x80485b4
  b *0x8048707
  run TWCTF
  set $i=$i+1
  set *(char*)($ebp-0xc)=$i
  continue
  if ($eax==0x95)
    print $i
    x/256xb $esp+0x1c
    set $i=256
  end
  stop
end
end
```

得到表就能照着把flag搞出来了。

```python
import re
a = "95eeaf95ef94234999582f722f492f72b19a7aaf72e6e776b57aee722fe77ab5ad9aaeb156729676ae7a236d99b1df4a"
box = '''
0xffffcfbc:	0xd6	0xc9	0xc2	0xce	0x47	0xde	0xda	0x70
0xffffcfc4:	0x85	0xb4	0xd2	0x9e	0x4b	0x62	0x1e	0xc3
0xffffcfcc:	0x7f	0x37	0x7c	0xc8	0x4f	0xec	0xf2	0x45
0xffffcfd4:	0x18	0x61	0x17	0x1a	0x29	0x11	0xc7	0x75
0xffffcfdc:	0x02	0x48	0x26	0x93	0x83	0x8a	0x42	0x79
0xffffcfe4:	0x81	0x10	0x50	0x44	0xc4	0x6d	0x84	0xa0
0xffffcfec:	0xb1	0x72	0x96	0x76	0xad	0x23	0xb0	0x2f
0xffffcff4:	0xb2	0xa7	0x35	0x57	0x5e	0x92	0x07	0xc0
0xffffcffc:	0xbc	0x36	0x99	0xaf	0xae	0xdb	0xef	0x15
0xffffd004:	0xe7	0x8e	0x63	0x06	0x9c	0x56	0x9a	0x31
0xffffd00c:	0xe6	0x64	0xb5	0x58	0x95	0x49	0x04	0xee
0xffffd014:	0xdf	0x7e	0x0b	0x8c	0xff	0xf9	0xed	0x7a
0xffffd01c:	0x65	0x5a	0x1f	0x4e	0xf6	0xf8	0x86	0x30
0xffffd024:	0xf0	0x4c	0xb7	0xca	0xe5	0x89	0x2a	0x1d
0xffffd02c:	0xe4	0x16	0xf5	0x3a	0x27	0x28	0x8d	0x40
0xffffd034:	0x09	0x03	0x6f	0x94	0xa5	0x4a	0x46	0x67
0xffffd03c:	0x78	0xb9	0xa6	0x59	0xea	0x22	0xf1	0xa2
0xffffd044:	0x71	0x12	0xcb	0x88	0xd1	0xe8	0xac	0xc6
0xffffd04c:	0xd5	0x34	0xfa	0x69	0x97	0x9f	0x25	0x3d
0xffffd054:	0xf3	0x5b	0x0d	0xa1	0x6b	0xeb	0xbe	0x6e
0xffffd05c:	0x55	0x87	0x8f	0xbf	0xfc	0xb3	0x91	0xe9
0xffffd064:	0x77	0x66	0x19	0xd7	0x24	0x20	0x51	0xcc
0xffffd06c:	0x52	0x7d	0x82	0xd8	0x38	0x60	0xfb	0x1c
0xffffd074:	0xd9	0xe3	0x41	0x5f	0xd0	0xcf	0x1b	0xbd
0xffffd07c:	0x0f	0xcd	0x90	0x9b	0xa9	0x13	0x01	0x73
0xffffd084:	0x5d	0x68	0xc1	0xaa	0xfe	0x08	0x3e	0x3f
0xffffd08c:	0xc5	0x8b	0x00	0xd3	0xfd	0xb6	0x43	0xbb
0xffffd094:	0xd4	0x80	0xe2	0x0c	0x33	0x74	0xa8	0x2b
0xffffd09c:	0x54	0x4d	0x2d	0xa4	0xdc	0x6c	0x3b	0x21
0xffffd0a4:	0x2e	0xab	0x32	0x5c	0x7b	0xe0	0x9d	0x6a
0xffffd0ac:	0x39	0x14	0x3c	0xb8	0x0a	0x53	0xf7	0xdd
0xffffd0b4:	0xf4	0x2c	0x98	0xba	0x05	0xe1	0x0e	0xa3
'''
box = re.sub(r'(0xffff[a-z0-9][a-z0-9][a-z0-9][a-z0-9])',"",box)
p = re.compile(r'(0x[a-z0-9][a-z0-9])')
tmp = p.findall(box)
tmp = [int(i,16) for i in tmp]
print(tmp)
for i in range(len(a)//2):
	print(chr(tmp.index(int(a[i*2:i*2+2],16))),end="")
```

或者像这位[大佬](https://www.megabeets.net/twctf-2016-reverse-reverse-box/)一样靠理解程序直接逆向。

## Flag
> TWCTF{5UBS717U710N_C1PH3R_W17H_R4ND0M123D_5-B0X}