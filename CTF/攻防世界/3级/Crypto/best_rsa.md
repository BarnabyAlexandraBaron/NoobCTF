# best_rsa

[题目地址](https://adworld.xctf.org.cn/challenges/details?hash=ba6b4cc7-87e3-4c5a-8d21-1dc1b65e9bb5_2)

密码学永远绕不开的话题——RSA。这次我们拿到了两组密文和公钥。两个公钥及其相似，除了末尾的几位有些不同。用python看一下公钥的内容。

```python
from Crypto.PublicKey import RSA
key1=RSA.importKey(open('你的公钥1地址').read())
key2=RSA.importkey(open('你的公钥2地址').read())
print(f"key1: n:{key1.n},e:{key1.e}\nkey2: n:{key2.n},e:{key2.e}")
```

> key1: n:13060424286033164731705267935214411273739909173486948413518022752305313862238166593214772698793487761875251030423516993519714215306808677724104692474199215119387725741906071553437840256786220484582884693286140537492541093086953005486704542435188521724013251087887351409946184501295224744819621937322469140771245380081663560150133162692174498642474588168444167533621259824640599530052827878558481036155222733986179487577693360697390152370901746112653758338456083440878726007229307830037808681050302990411238666727608253452573696904083133866093791985565118032742893247076947480766837941319251901579605233916076425572961,e:117<br>
key2: n:13060424286033164731705267935214411273739909173486948413518022752305313862238166593214772698793487761875251030423516993519714215306808677724104692474199215119387725741906071553437840256786220484582884693286140537492541093086953005486704542435188521724013251087887351409946184501295224744819621937322469140771245380081663560150133162692174498642474588168444167533621259824640599530052827878558481036155222733986179487577693360697390152370901746112653758338456083440878726007229307830037808681050302990411238666727608253452573696904083133866093791985565118032742893247076947480766837941319251901579605233916076425572961,e:65537

两者n完全一样，e不同。此时就要考虑共模攻击了。

- ### 共模攻击
    > 要求加密时使用的模数n相同，e不同且互质。此时就可以根据现有条件直接求出原文。

117和65537互质，现在就要考虑怎么实现共模攻击的脚本了。先把脚本放出来，我们一步一步解释。

```python
from Crypto.PublicKey import RSA
from Crypto.Util.number import long_to_bytes,bytes_to_long
from gmpy2 import invert
def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)
k1=RSA.importKey(open('你的公钥1地址').read())
k2=RSA.importKey(open('你的公钥2地址').read())
n=k1.n
with open("你的密文1地址",'rb') as f:
    c1=f.read()
with open("你的密文2地址",'rb') as f:
    c2=f.read()
c1=bytes_to_long(c1)
c2=bytes_to_long(c2)
_,s1,s2=egcd(k1.e,k2.e)
if s1<0:
	s1 = -s1
	c1 = invert(c1, n)
elif s2<0:
	s2 = -s2
	c2 = invert(c2, n)
m = pow(c1,s1,n)*pow(c2,s2,n) % n
flag = long_to_bytes(m)
print(flag)
```

想要理解共模攻击就要先知道一条公式。

- e1\*s1+e2\*s2 = 1

这里的e1，e2分别对应了k1，k2各自的e。s1和s2是我们要求的值。这条公式来自于一个关于最大公约数的基本事实：给予二个整数a、b，必存在整数x、y使得ax + by = gcd(a,b)。求x和y的值就要用到上面的egcd方法，也就是[扩展欧几里得算法](https://zhuanlan.zhihu.com/p/42707457)（我数学不好只能靠你们自己了）

egcd求出重要的s1和s2后就可以找flag。先等一下，为啥知道s1和s2就能知道flag呢？这里我找到了个[证明](https://www.cnblogs.com/gwind/p/8013154.html)，还算清晰，注意模的[运算规则](https://www.cnblogs.com/gwind/p/8013154.html)中的幂法则和分配律。

还有最后一个解密的关键点。从前面的式子e1\*s1 + e2\*s2 = 1可以知道，s1、s2中有一个为负数，而负数次幂运算，比如这里求c2的s2次幂，需要先计算c2的模反元素c2r，然后再求c2r的-s2次幂。这也就是为什么要放if-elif分支然后求模逆元的原因。

从刚刚给的证明中可以看到c1^s1\*c2^s2 = m。最后我们把数字结果转成bytes就行了。

## Flag
  > flag{interesting_rsa}