# babyenc

[题目地址](https://adworld.xctf.org.cn/challenges/details?hash=a9bbc1f0-6a1b-11ed-ab28-000c29bc20bf&task_category_id=5)

出题人直接把答案告诉我们一定是有什么深意吧。

题目如下（省去数据部分）：

```python
from Crypto.Util.number import *
import gmpy2
flag="flag{when_to_leave_2333}"
def pad(m):
    pad_length = 8 - len(m)
    return pad_length*'0'+m
def fx(i):
    return i**2-e
def en(d):
    return (d<<200)^e
m = [flag[8*i:8*(i+1)] for i in range(len(pad(flag)) // 8)] #将flag每8个字符分为一组，不足的以0补齐
print(m)
e=getPrime(3) #这个e非常小，实验了一下，只有5和7两种可能，这里是5
p=getPrime(1024)
q=getPrime(1024)
phi=(p-1)*(q-1)
d=gmpy2.invert(e,phi)
n=p*q
hint=gmpy2.powmod(d,e,n) #第一感觉是低加密质数攻击，理论上可以爆破
print("fxe=",fx(e)) #没啥用，靠猜都猜得到e是5
print("hint=",hint)
c=[]
for t in m:
    c.append(int(bytes_to_long(bytes(t.encode()))^d)) #每次flag部分都与d异或
    # print(bytes_to_long(bytes(t.encode())).bit_length())
    d=en(d) #然后改变d
print("c=",c)
print("n=",p*q)
```

正准备分析，发现开头有个flag的定义。emmm，一定是出题人拿来给我们做实验的，不过提交试一下也无妨。结果直接对了。就当啥也没发生，我们正式开始分析。

从文件中不难发现e很小，符合低加密质数攻击的特征。本来想靠爆破爆出d，不知道是不是因为我的破电脑算力太差，爆了几十秒没出来。正好我有另一个思路，就放弃了。这所谓的“另一个思路”也是爆破，不过快多了。我们知道flag都是有格式的，不同比赛有指定的格式，一般就是flag{xxx}。数一下，已知部分flag{长度为5，剩下不知道的3位完全可以爆破。爆破出来的值与c[0]异或就是未经改变的d。至于怎么验证d对不对，可以利用hint。那脚本就很简单了。

```python
from string import printable
from Crypto.Util.number import *
import gmpy2
import itertools
e=5
def en(d):
    return (d<<200)^e
flag=b'flag{'
res=itertools.product(printable,repeat=3)
hint= 8282772384180423780434969695316654217933279719921844963450941599821080258207409643101106039089534365856110410836993096655221478084992933987649557188017995847085529259273297251015374945825573341659145651311382688764396455313234252121981057379493828411331776961191001466467217365289579253456934387796497504717476467816877646033905988733254688159698104519507602496544323144084876021096979009890514766411776093122802091691430533679930656778288365431063348851868268721671790548288881603229702590054631569010679663061729338559717267663412370387907466479777559597065171175185227749864614788598875213729112540897972392462988
c= [2483906376907590114527972298774419824357454769905674978436901262134290016560583940409524072673175559076225948704603189300450466172218798653045198850197499084138403134804402155768496959511639034227742768268659103160267099340564787638191215771193444093063549609885784038647508472926520168310860638393983589267767569996609656830999984982908701307882735753599851425320886101729526082344489390584989967756201405199409366366350262872166037637378335052683950842666230422382564719337588077218340028555590969831692591219879577306898872342598441722873803659309422170978589545819437706469870573971138331293208088408298468758868, 3991483655430317224369049299636024823755150040927472716462290683190150158985722973263124114045548597355965931462225410785034702609442306045995891961308504149996183954753022046992268723269220550317815764036285641159003467988591868558295900091178482037825182533458227554945517594729201449623105664180084211079097330232460281283020803936458504152481144064559944840947056347049080900020249453967188979854267101853265615723854991370246201599373458103880681724063433288680839900532883457052474663996766495575489154993471878679416775661992170991470426567293186308297912247089645514570760151582865868275361191781449111057947190090498413036309765608493185565138686206694137174143296868, 6414066938948919390568245150415827256775963517639520479196092321847038845181742340735616025522828323567490114129842590353574045586761167574350843137327868669898352620982406939847120871205476893175332714246395868096036743508811487040180369235668768287186274629016527488921362482727277190769848180794676252266024014627760603119348326316069379603839759674600275001205918975153162145725208743857660027624951496626452138548129325064234336551452754414942532395985087729410818687018863557338080258926721841803851997279050294012917510717033402277270334004459330544646150225506918203587288762077393143594148102900043320898629569578498227917968845430196445533787677740427179575416419393717144274074394255621465243033980657763900011850092327940984]
n= 12419531884537950572639861493872099121787273849528374892184506310671450082802919702047620363365877795381129743523015946502252330861093993265225994250987495420692015674022010778842484797558195171138713841343295515801335496702823938190956078855967220465317748049428920193237542364632600841554303191969917946339060899291147723043514372482451615217479137726910954721295208555690535560821569044808335546100581434127356419644097884918998693165950062670450345683133252001223947090080674704162092213862770607942803219395082772015062325066307118340380641869959061887341339556967161369151689048629611882099069592519886990616441
for i in res:
    d=bytes_to_long(flag+''.join(i).encode())^c[0]
    if gmpy2.powmod(d,e,n)==hint:
        break
for i in c:
    print(long_to_bytes(i^d).decode(),end='')
    d=en(d)
```

## Flag
> flag{when_to_leave_2333}