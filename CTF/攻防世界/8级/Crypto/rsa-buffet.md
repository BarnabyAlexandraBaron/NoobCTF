# rsa-buffet

[题目地址](https://adworld.xctf.org.cn/challenges/details?hash=a1e50a10-7c7f-4124-8223-a0981a69ee21_2)

5个愿望一次满足。

附件打开看看，9个证书认真的吗？更奇怪的是只有5个密文。还给了两个脚本。

```python
# pip install secretsharing
# https://github.com/blockstack/secret-sharing
from secretsharing import PlaintextToHexSecretSharer as SS

with open('message1.txt', 'r') as f:
  PLAINTEXTS = [f.read()] * 5

for i in range(2, 6):
  with open('message' + str(i) + '.txt', 'r') as f:
    msg = f.read()
  shares = SS.split_secret(msg, i, 5)
  for j in range(5):
    PLAINTEXTS[j] += shares[j] + '\n'

for j in range(5):
  with open('plaintext-' + str(j+1) + '.txt', 'w') as f:
    f.write(PLAINTEXTS[j])
```

这个脚本是恢复明文的，和加密过程没有关系。脚本中提到的[secretsharing](https://zhuanlan.zhihu.com/p/44999983)是和rsa没啥关系的另一种加密，先不管，我也不懂啊。

```python
import random
from Crypto.Cipher import AES,PKCS1_OAEP
from Crypto.PublicKey import RSA

def get_rand_bytes(length):
  return "".join([chr(random.randrange(256)) for i in range(length)])

def encrypt(public_key, message):
  """Encrypt a message with a given public key.
  
  Takes in a public_key generated by Crypto.PublicKey.RSA, which must be of
  size exactly 4096
  """
  symmetric_key = get_rand_bytes(32)
  msg_header = PKCS1_OAEP.new(public_key).encrypt(symmetric_key)
  assert len(msg_header) == 512
  msg_iv = get_rand_bytes(16)
  msg_body = AES.new(symmetric_key,
      mode=AES.MODE_CFB,
      IV=msg_iv).encrypt(message)
  return msg_header + msg_iv + msg_body

def decrypt(private_key, ciphertext):
  """Decrypt a message with a given private key.

  Takes in a private_key generated by Crypto.PublicKey.RSA, which must be of
  size exactly 4096

  If the ciphertext is invalid, return None
  """
  if len(ciphertext) < 512 + 16:
    return None
  msg_header = ciphertext[:512]
  msg_iv = ciphertext[512:512+16]
  msg_body = ciphertext[512+16:]
  try:
    symmetric_key = PKCS1_OAEP.new(private_key).decrypt(msg_header)
  except ValueError:
    return None
  if len(symmetric_key) != 32:
    return None
  return AES.new(symmetric_key,
      mode=AES.MODE_CFB,
      IV=msg_iv).decrypt(msg_body)


if __name__=="__main__":
  # Test!
  message = "This is my test message.  It's kind of ssilly.wireheirhgwieruhgwieurghwiregsilly.wireheirhgwieruhgwieurghwiregsilly.wireheirhgwieruhgwieurghwiregsilly.wireheirhgwieruhgwieurghwiregsilly.wireheirhgwieruhgwieurghwiregsilly.wireheirhgwieruhgwieurghwiregsilly.wireheirhgwieruhgwieurghwiregsilly.wireheirhgwieruhgwieurghwiregsilly.wireheirhgwieruhgwieurghwiregsilly.wireheirhgwieruhgwieurghwiregsilly.wireheirhgwieruhgwieurghwiregilly.wireheirhgwieruhgwieurghwireg"
  private_key = RSA.generate(4096)
  public_key = private_key.publickey()
  ciphertext = encrypt(public_key, message)
  assert message == decrypt(private_key, ciphertext)
```

整整9个证书，脚本里没有足够的提示。没关系，直接[rsactftool](https://github.com/RsaCtfTool/RsaCtfTool)把可能攻击全部试一遍，看看效果怎样。看的[wp](https://ctf.rip/bkp2017-rsabuffet/)的作者还有一个可以同时破解多个key的[fork](https://github.com/sourcekris/RsaCtfTool)。各位看心情了。fork的工具跑一下直接就取得了巨大进展。

- 费马分解得到key-1.pem的私钥
- factordb得到key-2.pem的私钥
- Wiener attack得到key-3.pem的私钥
- 从key-0.pem和key-6.pem中找到了一个公共大质数

作者还用自己的脚本把key-0.pem和key-6.pem的私钥复原了。得到私钥后直接用脚本给的decrypt函数解密，私钥对应什么密文可以爆破，拿每个key去解密每个密文。对应情况是：key1 +密文5，key2 +密文1，key3 +密文4。最后用secretsharing恢复flag。

```python
from Crypto.Cipher import AES,PKCS1_OAEP
from Crypto.PublicKey import RSA
from secretsharing import PlaintextToHexSecretSharer as rs
import glob
def decrypt(private_key, ciphertext):
  if len(ciphertext) < 512 + 16:
    return None
  msg_header = ciphertext[:512]
  msg_iv = ciphertext[512:512+16]
  msg_body = ciphertext[512+16:]
  try:
    symmetric_key = PKCS1_OAEP.new(private_key).decrypt(msg_header)
  except ValueError:
    return None
  if len(symmetric_key) != 32:
    return None
  return AES.new(symmetric_key,
      mode=AES.MODE_CFB,
      IV=msg_iv).decrypt(msg_body)
if __name__=="__main__":
  cts = glob.glob('ciphertext-?.bin')
  keys = glob.glob('key-?.priv')
  secrets = []
  for k in keys:
     for c in cts:
        private_key = RSA.importKey(open(k).read())
        ciphertext = open(c,'rb').read()
        plaintext  = decrypt(private_key,ciphertext)
        
        if plaintext is not None:
           if 'Congrat' in plaintext:
              secrets = secrets + plaintext.splitlines()[1:]
  for sec1 in [x for x in secrets if '1-' in x]:
     for sec2 in [x for x in secrets if '4-' in x]:
        for sec3 in [x for x in secrets if '5-' in x]:
           rec = rs.recover_secret([sec1,sec2,sec3])
           if 'FLAG' in rec:
              print rec
```

基本就是上面那篇wp的翻译了。脚本看起来复杂，其实大部分都是抄的decrypt函数，然后用每个key爆破密文看对应情况。每个得到的明文中有4个相同编号的内容，全部组合一遍看哪些是secretsharing需要的部分，有FLAG字样就打印。

- ### Flag
  > FLAG{ndQzjRpnSP60NgWET6jX}