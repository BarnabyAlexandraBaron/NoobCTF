# MyDriver2-397

[题目地址](https://adworld.xctf.org.cn/challenges/details?hash=7d3b6e72-0cbc-4957-b4c2-9ee26bcadbed_2&task_category_id=4)、

逆向逆的东西越来越奇怪了。

下载得到的文件后缀是[sys](https://www.wenjianbaike.com/sys.html#:~:text=SYS%E6%96%87%E4%BB%B6%E6%98%AFDOS%E5%92%8C,%E5%92%8C%E5%85%B6%E4%BB%96%E6%A0%B8%E5%BF%83Windows%E5%8A%9F%E8%83%BD%E3%80%82&text=SYS%E6%96%87%E4%BB%B6%E6%9C%80%E5%B8%B8%E8%A7%81%E4%BA%8E,C%3A%5CWindows%5Csystem32%5Cdrivers)。系统文件，管他的放进ida再说。发现有一个DriverEntry函数，那就是驱动器了。逆向驱动器首要任务就是找DriverEntry，跟逆别的程序先找main一样。然后我就不会了。完全不知道在干啥。上[wp](https://www.cnblogs.com/lordtianqiyi/articles/15861215.html)。

逆向字如其名。肯定要倒着来。问题是驱动器怎么倒着来呢？一般程序有个判断，驱动器可没有这种东西。相应地我们要从驱动器卸载的时候看起。DriverEntry第16行，设置了unload的函数为sub_11660。里面又调用了一个函数sub_115dc。到这里就卡住了，暂时看不出来别的东西。

那就继续往下看别的函数的调用。sub_11008创建一个文件，不用理。再往下的sub_113c8有点东西，出现了异或逻辑。这种代码一般和flag有关，要么直接相关要么间接相关，当然也有烟雾弹的可能。找一下byte_16390的引用，发现其他函数里也有。在sub_112b4的引用中似乎是在把这个值写到某个文件中。最后还有一个sub_11d40的引用。这个函数里面有if判断，外面还调用了sub_112b4。没有更改byte_16390的操作，不管。先按照sub_113c8的逻辑写出脚本。

```python
byte_16390 = [  0x70, 0x74, 0x37, 0x65, 0x47, 0x66, 0x05, 0x61, 0x11, 0x20,
  0x0C, 0x73, 0x6D, 0x41, 0x3A, 0x73, 0x36, 0x6D, 0x16, 0x6C,
  0x09, 0x5F, 0x28, 0x6E, 0x0B, 0x69, 0x31, 0x65, 0x6D, 0x68,
  0x5C, 0x6F, 0x58, 0x5F, 0x6A, 0x72, 0x02, 0x00, 0x78, 0x00,
  0x74, 0x00, 0x50, 0x00, 0x5F, 0x00, 0x67, 0x00, 0x69, 0x00,
  0x76, 0x00, 0x65, 0x00, 0x4D, 0x00, 0x65, 0x00, 0x5F, 0x00,
  0x66, 0x00, 0x6C, 0x00, 0x61, 0x00, 0x67, 0x00, 0x5F, 0x00,
  0x32, 0x00, 0x33, 0x00, 0x33, 0x00, 0x2E, 0x00, 0x74, 0x00,
  0x78, 0x00, 0x74, 0x00, 0x50, 0x00, 0x5F, 0x00, 0x67, 0x00,
  0x69, 0x00, 0x76, 0x00, 0x65, 0x00, 0x4D, 0x00, 0x65, 0x00,
  0x5F, 0x00, 0x66, 0x00, 0x6C, 0x00, 0x61, 0x00, 0x67, 0x00,
  0x5F, 0x00, 0x32, 0x00, 0x33, 0x00, 0x33, 0x00, 0x2E, 0x00,
  0x74, 0x00, 0x78, 0x00, 0x74, 0x00, 0x50, 0x00]

byte_16310 = [
0x95, 0x13, 0x6E, 0x5C, 0xA2, 0x13, 0x58, 0x5C, 0xB3, 0x13,
0x54, 0x5C, 0x88, 0x13, 0x54, 0x5C, 0x9A, 0x13, 0x57, 0x5C,
0xA9, 0x13, 0x50, 0x5C, 0xA2, 0x13, 0x6E, 0x5C, 0xF7, 0x13,
0x02, 0x5C, 0xF6, 0x13, 0x1F, 0x5C, 0xB1, 0x13, 0x49, 0x5C,
0xB1, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]

v1 = 0x54321CCC & 0xF0F0F0F0F0F0F0F0 ^ 0xCCC12345 & 0xF0F0F0F0F0F0F0F
v2 = v1 - 0x5C31139B
# print(v2)

for i in range(32):
    byte_16310[4*i] ^= (v1 & 0x000000ff)
    byte_16310[4*i+1] ^= ((v1 & 0x0000ff00)>>8)
    byte_16310[4*i + 2] ^= ((v1 & 0x00ff0000)>>16)
    byte_16310[4*i + 3] ^= ((v1 & 0xff000000)>>24)


byte_16310[v2] = 0
byte_16310[v2 + 1] = 0

v4 = 0
for i in range(128):
    byte_16390[i] ^= byte_16310[v4]
    v4 = (v4 + 1) % v2
k = 0
for i in byte_16390:
    if (i == 0):
        break
    else:
        k= k + 1

for i in range(k):
    print(chr(byte_16390[i] & 0xff),end = '')
```

整个脚本看起来很复杂，其实就是原程序逻辑抄下来而已。程序里没有的位运算是为了让python符合c语言字节这些东西。

## Flag
> RCTF{A_simple_Inline_hook_Drv}