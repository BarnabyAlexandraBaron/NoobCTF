# [RoarCTF2019]babyRSA

[题目地址](https://buuoj.cn/challenges#[RoarCTF2019]babyRSA)

这是第多少个babyrsa了？还是不会，看[wp](https://www.cnblogs.com/jane315/p/13805724.html)。

```python
import sympy
import random

def myGetPrime():
    A= getPrime(513)
    print(A)
    B=A-random.randint(1e3,1e5)
    print(B)
    return sympy.nextPrime((B!)%A)
p=myGetPrime()
#A1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407
#B1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596

q=myGetPrime()
#A2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927
#B2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026

r=myGetPrime()

n=p\*q\*r
#n=85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733
c=pow(flag,e,n)
#e=0x1001
#c=75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428
#so,what is the flag?
```

我这辈子都不会忘了阶乘，之前比赛就是死在一个很简单的威尔逊定理上。没错这道题也是威尔逊：

$(p-1)!+1\equiv 0 (\mod p)$

换句话说就是 $(p-1)!\equiv -1 (\mod p)$ 。这题用了3个质数，意味着想找到phi就要找到p，q和r。因为程序本身用了`sympy.nextPrime((B!)%A)`，所以我们只需要找`(B!)%A`。有点像威尔逊定理，但是模的是A，应该是A的阶乘才对。一切都在引导我们将B的阶乘和A的阶乘联系起来。已知 $(A-1)!\equiv -1\mod A$ ，展开得到 $(A-1)\*(A-2)\*(A-3)\*...\*(B+2)\*(B+1)\*B!\equiv -1\mod A$ 。因为B本身就是A减去某个数字，所以其阶乘一定会包含在A的阶乘里。那么现在我们应该尝试找到 $(A-1)\*(A-2)\*(A-3)\*...\*(B+2)\*(B+1)$ 模A的逆元C，两边同乘逆元C，得到 $B!=-1\*C\mod A$，成功找到B!。

```python
from Crypto.Util.number import *
import gmpy2


def wilison(b,a):
    p=1
    b=b+1
    while b<a:
        p*=b
        p=p%a
        b=b+1
    return p
A1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407
B1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596
A2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927
B2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026
n=85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733
e=0x1001
c=75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428

invert1=inverse(wilison(B1,A1),A1)   #利用wilison算法找到(A-1)*(A-2)*(A-3)*...*(B+2)*(B+1)部分后求逆元
invert2=inverse(wilison(B2,A2),A2)

p=gmpy2.next_prime((invert1*(-1))%A1)    #找到逆元后乘上-1得到B!，模A1求得p
q=gmpy2.next_prime((invert2*(-1))%A2)
print(p,q)
r=n//p//q
print("r:",r)
phi=(p-1)*(q-1)*(r-1)  #3个质数情况的phi
d=inverse(e,phi)
s=pow(c,d,n)
print(long_to_bytes(s))
```

## Flag
> flag{wm-CongrAtu1ation4-1t4-ju4t-A-bAby-R4A}