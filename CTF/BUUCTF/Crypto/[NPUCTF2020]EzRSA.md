# [NPUCTF2020]EzRSA

[题目地址](https://buuoj.cn/challenges#[NPUCTF2020]EzRSA)

老师这题我学过！但是我没做出来！

```python
from gmpy2 import lcm , powmod , invert , gcd , mpz
from Crypto.Util.number import getPrime
from sympy import nextprime
from random import randint
p = getPrime(1024)
q = getPrime(1024)
n = p * q
gift = lcm(p - 1 , q - 1)
e = 54722
flag = b'NPUCTF{******************}'
m = int.from_bytes(flag , 'big')
c = powmod(m , e , n)
print('n: ' , n)
print('gift: ' , gift)
print('c: ' , c)

#n:  17083941230213489700426636484487738282426471494607098847295335339638177583685457921198569105417734668692072727759139358207667248703952436680183153327606147421932365889983347282046439156176685765143620637107347870401946946501620531665573668068349080410807996582297505889946205052879002028936125315312256470583622913646319779125559691270916064588684997382451412747432722966919513413709987353038375477178385125453567111965259721484997156799355617642131569095810304077131053588483057244340742751804935494087687363416921314041547093118565767609667033859583125275322077617576783247853718516166743858265291135353895239981121
#gift:  2135492653776686212553329560560967285303308936825887355911916917454772197960682240149821138177216833586509090969892419775958406087994054585022894165950768427741545736247918410255804894522085720642952579638418483800243368312702566458196708508543635051350999572787188236243275631609875253617015664414032058822919469443284453403064076232765024248435543326597418851751586308514540124571309152787559712950209357825576896132278045112177910266019741013995106579484868768251084453338417115483515132869594712162052362083414163954681306259137057581036657441897428432575924018950961141822554251369262248368899977337886190114104
#c:  3738960639194737957667684143565005503596276451617922474669745529299929395507971435311181578387223323429323286927370576955078618335757508161263585164126047545413028829873269342924092339298957635079736446851837414357757312525158356579607212496060244403765822636515347192211817658170822313646743520831977673861869637519843133863288550058359429455052676323196728280408508614527953057214779165450356577820378810467527006377296194102671360302059901897977339728292345132827184227155061326328585640019916328847372295754472832318258636054663091475801235050657401857262960415898483713074139212596685365780269667500271108538319
```

总是在该想多点的时候想得过于简单，比如这题，我看gift给了p-1和q-1的lcm，就下意识以为这就是toitent，毕竟`toitent=(p-1)*(q-1)`。事实证明没那么多简单，这次的情况下两者相乘的结果不是lcm。lcm的算法我学[数论](https://github.com/C0nstellati0n/NoobCTF/blob/main/%E7%AC%94%E8%AE%B0/Crypto/%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0.md#divisibility-and-euclids-algorithms)时学过,lcm(a,b)= $\frac{ab}{gcd(a,b)}$ 。套用到现在的情况，lcm(p-1,q-1)= $\frac{(p-1)(q-1)}{gcd(p-1,q-1)}$ 。我们只需要找到gcd(p-1,q-1)，与gift相乘，就能得到toitent了。

不过题目没给gcd，只能爆破了。[大佬](https://blog.csdn.net/shshss64/article/details/127294698)提供了清晰的思路：gift和n分别为616和617位, $(p-1)(q-1)\approx n$ ，gift乘k等于n，这个k应该不大，直接爆破。爆破得到一个值后，尝试解密。然而最后还有一个坎：e是偶数，不与toitent互质。这好办，这么推导一下就看出来了：

$m^e\equiv c\mod n$<br>

因为e和toitent不互质，我们尝试把e除以2，当然要保证等值：

$m^{\frac{e}{2}\times 2}\equiv c\mod n$

幂法则变形得到：

$m^{\frac{e}{2}}\times m^2 \equiv c\mod n$

 $\frac{e}{2}$ 和toitent互质，能找到逆元。两边乘以逆元d后：

$m^{\frac{e}{2}}\times d\times m^2 \equiv c\times d\mod n$

根据逆元的性质最终得到：

$m^2 \equiv c\times d\mod n$

也就是说最后把m开方就是flag了。

```python
import gmpy2
from Crypto.Util.number import *
 
n=17083941230213489700426636484487738282426471494607098847295335339638177583685457921198569105417734668692072727759139358207667248703952436680183153327606147421932365889983347282046439156176685765143620637107347870401946946501620531665573668068349080410807996582297505889946205052879002028936125315312256470583622913646319779125559691270916064588684997382451412747432722966919513413709987353038375477178385125453567111965259721484997156799355617642131569095810304077131053588483057244340742751804935494087687363416921314041547093118565767609667033859583125275322077617576783247853718516166743858265291135353895239981121
gift=2135492653776686212553329560560967285303308936825887355911916917454772197960682240149821138177216833586509090969892419775958406087994054585022894165950768427741545736247918410255804894522085720642952579638418483800243368312702566458196708508543635051350999572787188236243275631609875253617015664414032058822919469443284453403064076232765024248435543326597418851751586308514540124571309152787559712950209357825576896132278045112177910266019741013995106579484868768251084453338417115483515132869594712162052362083414163954681306259137057581036657441897428432575924018950961141822554251369262248368899977337886190114104
c=3738960639194737957667684143565005503596276451617922474669745529299929395507971435311181578387223323429323286927370576955078618335757508161263585164126047545413028829873269342924092339298957635079736446851837414357757312525158356579607212496060244403765822636515347192211817658170822313646743520831977673861869637519843133863288550058359429455052676323196728280408508614527953057214779165450356577820378810467527006377296194102671360302059901897977339728292345132827184227155061326328585640019916328847372295754472832318258636054663091475801235050657401857262960415898483713074139212596685365780269667500271108538319
e = 54722
print(len(str(n)))
print(len(str(gift)))
 
e=e//2
for i in range(10):
    phi=gift*i
    try:
        d=gmpy2.invert(e,phi)
        m=gmpy2.powmod(c,d,n)
        m=long_to_bytes(int(gmpy2.iroot(m,2)[0]))
        print(m)
        break
    except:
        pass
```

## Flag
> flag{diff1cult_rsa_1s_e@sy}