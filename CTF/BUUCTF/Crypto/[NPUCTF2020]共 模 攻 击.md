# [NPUCTF2020]共 模 攻 击

[题目地址](https://buuoj.cn/challenges#[NPUCTF2020]%E5%85%B1%20%E6%A8%A1%20%E6%94%BB%20%E5%87%BB)

你 确 定 这 是 共 模 攻 击 ？

给了个hint和task。

```python
#hint.py
from gmpy2 import *
from Crypto.Util.number import *
from secret import hint

m = bytes_to_long(hint)
p = getPrime(256)
c = pow(m, 256, p)
print(p)

p, q = getPrime(256), getPrime(256)
n = p * q
e1, e2 = getPrime(32), getPrime(32)
c1, c2 = pow(c, e1, n), pow(c, e2, n)
print(n)
print(e1, c1)
print(e2, c2)

'''
107316975771284342108362954945096489708900302633734520943905283655283318535709
6807492006219935335233722232024809784434293293172317282814978688931711423939629682224374870233587969960713638310068784415474535033780772766171320461281579
2303413961 1754421169036191391717309256938035960912941109206872374826444526733030696056821731708193270151759843780894750696642659795452787547355043345348714129217723
2622163991 1613454015951555289711148366977297613624544025937559371784736059448454437652633847111272619248126613500028992813732842041018588707201458398726700828844249
'''
```

```python
#task.py
from gmpy2 import *
from Crypto.Util.number import *
from secret import flag

flag = flag.strip(b"npuctf{").strip(b"}")
m = bytes_to_long(flag)

p, q = getPrime(512), getPrime(512)
n = p * q
e1, e2 = p, q
c1, c2 = pow(m, e1, n), pow(m, e2, n)

print(n)
print(c1)
print(c2)

'''
128205304743751985889679351195836799434324346996129753896234917982647254577214018524580290192396070591032007818847697193260130051396080104704981594190602854241936777324431673564677900773992273463534717009587530152480725448774018550562603894883079711995434332008363470321069097619786793617099517770260029108149
96860654235275202217368130195089839608037558388884522737500611121271571335123981588807994043800468529002147570655597610639680977780779494880330669466389788497046710319213376228391138021976388925171307760030058456934898771589435836261317283743951614505136840364638706914424433566782044926111639955612412134198
9566853166416448316408476072940703716510748416699965603380497338943730666656667456274146023583837768495637484138572090891246105018219222267465595710692705776272469703739932909158740030049375350999465338363044226512016686534246611049299981674236577960786526527933966681954486377462298197949323271904405241585
'''
```

我直接看的task，hint没多看，以为考点就是题目的共模攻击。掏出之前的脚本，兴冲冲套用的时候，笑容消失。你两个e怎么是p和q啊？你的e有问题吧？无奈回去看hint。hint倒真的是个共模攻击，就是e和phi(n)不互质到家了，除多少个2都不行，后面看[wp](https://blog.csdn.net/qq_51999772/article/details/121451010)知道要用[sympy.nthroot_mod](https://www.osgeo.cn/sympy/modules/ntheory.html)函数。脚本最后一起放，解出来是`b'm.bit_length() < 400'`。

当题目刻意提到某某的长度时，就要考虑是否是[Coppersmith定理](https://blog.csdn.net/qq_51999772/article/details/123620932)。这个定理阐述了下面的事实：

现有一个e阶的多项式f，即可：
- 给定β，快速求出模某个n的因数b意义下较小的根，其中 $b ≥ n^β$ ( $0<b\leq 1$ ).
- 在模n意义下，快速求出 $n^{\frac{\beta^2}{e}}$ 以内的根

一般采用 Sage 实现的 small_roots 方法。[此处](https://jayxv.github.io/2020/08/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bcoppersmith/)有更详细的补充。简而言之，就是有一个函数，比如 $F(x)=x^3+x+123$ ，还有一个模数，比如m=77。假设存在一个 $x_0$ 满足 $F(x_0)\equiv 0\mod m$ ，并且 $x_0$ 小于某个特定的值，那么就可以用Coppersmith’s Method去找到这个 $x_0$ 。

wp已经给出如何构造式子的证明了。已知：

$c_1\equiv m^p\mod n$<Br>
$c_2\equiv m^q\mod n$

根据费马小定理 $x^p\equiv x\mod p$ ,可得：

$m^p\equiv m\mod p$<Br>
$m^q\equiv q\mod q$

转换即得：

$m^p=m+k_1*p$<Br>
$m^q=m+k_2*q$

因为 $c_1,c_2$ 分别与 $m^p,m^q$ 同余，就有：

$c_1\equiv m^p\equiv m+k_1*p\mod n$<br>
$c_2\equiv m^q\equiv m+k_2*q\mod n$

继续转换为等式形式：

$c_1=m+k_1\*p\*k_3\*p\*q=m+(k_1\*k_3\*q\*p)p$<br>
$c_2=m+k_2\*q\*k_4\*p\*q=m+(k_2\*k_4\*q\*p)q$

把 $(k_1\*k_3\*q\*p)$ 叫做k， $(k_2\*k_4\*q\*p)$ 叫做k'，就有：

$c_1=m+kp$<br>
$c_2=m+k'q$

要求的是m，所以要构造关于m的同余式。根据上方coppersmith的定义，要尽量让构造出的m的等式是n的倍数（也就是模n等于0）。虽然余数不等于0的情况也可以，但是这样就不能准确地知道余数是多少了，而“知道余数是多少”这点是必须的。

尝试将两个c相乘。

$c_1\*c_2=(m+kp)(m+k'q)=m^2+(kp+k'q)m+kk'n$

然后尝试将两个c相加并乘上m。

$m(c_1+c_2)=2m^2+(kp+k'q)m$

m的平方减去两式相加的结果即可得到我们想要的式子。

$m^2-c_1\*c_2+m(c_1+c_2)=m^2-\left(2m^2+\left(kp+k'q\right)m\right)+\left(m^2+\left(kp+k'q\right)m+kk'n\right)=kk'n\equiv 0\mod n$

最后就是脚本了。

```python
import gmpy2
from Crypto.Util.number import *
from sympy import *
# 求hint
p = 107316975771284342108362954945096489708900302633734520943905283655283318535709
n = 6807492006219935335233722232024809784434293293172317282814978688931711423939629682224374870233587969960713638310068784415474535033780772766171320461281579
e1 = 2303413961 
c1 = 1754421169036191391717309256938035960912941109206872374826444526733030696056821731708193270151759843780894750696642659795452787547355043345348714129217723
e2 = 2622163991 
c2 = 1613454015951555289711148366977297613624544025937559371784736059448454437652633847111272619248126613500028992813732842041018588707201458398726700828844249

_,s,t = gmpy2.gcdext(e1,e2)
c = pow(c1,s,n)*pow(c2,t,n) % n
e = 256
m = nthroot_mod(c,e,p)
print(long_to_bytes(m))
# 错误想法
# fai_p = p - 1
# com = gmpy2.gcd(e,fai_p)
# print(com)
# d = gmpy2.invert(e//com,fai_p)
# m = pow(c,d,p)

# 求flag
n = 128205304743751985889679351195836799434324346996129753896234917982647254577214018524580290192396070591032007818847697193260130051396080104704981594190602854241936777324431673564677900773992273463534717009587530152480725448774018550562603894883079711995434332008363470321069097619786793617099517770260029108149
c1 = 96860654235275202217368130195089839608037558388884522737500611121271571335123981588807994043800468529002147570655597610639680977780779494880330669466389788497046710319213376228391138021976388925171307760030058456934898771589435836261317283743951614505136840364638706914424433566782044926111639955612412134198
c2 = 9566853166416448316408476072940703716510748416699965603380497338943730666656667456274146023583837768495637484138572090891246105018219222267465595710692705776272469703739932909158740030049375350999465338363044226512016686534246611049299981674236577960786526527933966681954486377462298197949323271904405241585

sum = c1 + c2
pro = c1*c2
# sage
# R.<m> = Zmod(n)[]
# f = m^2 - sum*m + pro
# flag = f.smallroots(2^400)[0] #括号内的是根的边界，我们所求的根也就是m，这里hint已经给出了m.bit_length()<400
flag = 4242839043019782000788118887372132807371568279472499477998758466224002905442227156537788110520335652385855
print(long_to_bytes(flag))
```

sage的脚本涉及到一些[基本使用](https://lazzzaro.github.io/2020/05/10/crypto-crypto%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/index.html)。

```
R.<X> = PolynomialRing(Zmod(n))
#Zmod(n):指定模，定义界限为n的环；Z表示整数；指定模是划定这个环的界限，就是有效的数字只有从0到n，其他的都通过与n取模来保证在0～n这个范围内；Zmod代表这是一个整数域中的n模环
#ZZ：整数环；QQ：有理数环；RR：实数环；CC：复数环
#R：只是一个指针，指向用polynomialring指定的那个环（可以使用任意字符）
#PolynomialRing：这个就是说建立多项式环
#.<X>：指定一个变量的意思（可以用任意字符）
```

## Flag
> flga{verrrrrrry_345yyyyyyy_rsaaaaaaa_righttttttt?}