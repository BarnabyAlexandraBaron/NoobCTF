# [INSHack2019]Yet Another RSA Challenge - Part 1

[题目地址](https://buuoj.cn/challenges#[INSHack2019]Yet%20Another%20RSA%20Challenge%20-%20Part%201)

```python
import subprocess
p = subprocess.check_output('openssl prime -generate -bits 2048 -hex')
q = subprocess.check_output('openssl prime -generate -bits 2048 -hex')
flag = int('INSA{REDACTED}'.encode('hex'), 16)

N = int(p,16) * int(q,16)
print N
print '0x'+p.replace('9F','FC')
print pow(flag,65537,N)
```

我可太天真了，看到题目里把9F替换为FC就想着简简单单把FC替换回来就完事了，完全没想到p本身可能也有FC。知道思路后脚本也不好写，还是[wp](https://blog.csdn.net/zippo1234/article/details/109270719)强啊。

```python
import gmpy2
import itertools
from Crypto.Util.number import *

#TODO：导入初始化参数
n = 719579745653303119025873098043848913976880838286635817351790189702008424828505522253331968992725441130409959387942238566082746772468987336980704680915524591881919460709921709513741059003955050088052599067720107149755856317364317707629467090624585752920523062378696431510814381603360130752588995217840721808871896469275562085215852034302374902524921137398710508865248881286824902780186249148613287250056380811479959269915786545911048030947364841177976623684660771594747297272818410589981294227084173316280447729440036251406684111603371364957690353449585185893322538541593242187738587675489180722498945337715511212885934126635221601469699184812336984707723198731876940991485904637481371763302337637617744175461566445514603405016576604569057507997291470369704260553992902776099599438704680775883984720946337235834374667842758010444010254965664863296455406931885650448386682827401907759661117637294838753325610213809162253020362015045242003388829769019579522792182295457962911430276020610658073659629786668639126004851910536565721128484604554703970965744790413684836096724064390486888113608024265771815004188203124405817878645103282802994701531113849607969243815078720289912255827700390198089699808626116357304202660642601149742427766381
p = 'DCC5A0BD3A1FC0BEB0DA1C2E8CF6B474481B7C12849B76E03C4C946724DB577D2825D6AA193DB559BC9DBABE1DDE8B5E7805E48749EF002F622F7CDBD7853B200E2A027E87E331AFCFD066ED9900F1E5F5E5196A451A6F9E329EB889D773F08E5FBF45AACB818FD186DD74626180294DCC31805A88D1B71DE5BFEF3ED01F12678D906A833A78EDCE9BDAF22BBE45C0BFB7A82AFE42C1C3B8581C83BF43DFE31BFD81527E507686956458905CC9A660604552A060109DC81D01F229A264AB67C6D7168721AB36DE769CEAFB97F238050193EC942078DDF5329A387F46253A4411A9C8BB71F9AEB11AC9623E41C14FCD2739D76E69283E57DDB11FC531B4611EE3'
c = 596380963583874022971492302071822444225514552231574984926542429117396590795270181084030717066220888052607057994262255729890598322976783889090993129161030148064314476199052180347747135088933481343974996843632511300255010825580875930722684714290535684951679115573751200980708359500292172387447570080875531002842462002727646367063816531958020271149645805755077133231395881833164790825731218786554806777097126212126561056170733032553159740167058242065879953688453169613384659653035659118823444582576657499974059388261153064772228570460351169216103620379299362366574826080703907036316546232196313193923841110510170689800892941998845140534954264505413254429240789223724066502818922164419890197058252325607667959185100118251170368909192832882776642565026481260424714348087206462283972676596101498123547647078981435969530082351104111747783346230914935599764345176602456069568419879060577771404946743580809330315332836749661503035076868102720709045692483171306425207758972682717326821412843569770615848397477633761506670219845039890098105484693890695897858251238713238301401843678654564558196040100908796513657968507381392735855990706254646471937809011610992016368630851454275478216664521360246605400986428230407975530880206404171034278692756
e = 65537

#TODO：爆破p
#输出的p中的FC可能是原有的也有可能是被替换的，所以要对所有的FC进行爆破。
#第一步：将p按FC分割。去掉FC的同时分段。
ps = p.split('FC')
#初始化爆破过程参数
np = ''
np1 = 0
#第二步：生成字典，输出的p中有四个FC，所以要生成9F和FC随机组合的数组，如9F9F9FFC、9F9FFC9F。
a = ['9F', 'FC']
b = 4
#*[a] * b生成['9F', 'FC'] ['9F', 'FC'] ['9F', 'FC'] ['9F', 'FC']，product正是基于此构建笛卡尔积。如果直接a*b,只能得到一个数组[['9F', 'FC'], ['9F', 'FC'], ['9F', 'FC'], ['9F', 'FC']]，无法product求笛卡尔积，因为product要求两个可遍历对象。直接*a*b也不行，这样得到的是9F FC 9F FC 9F FC 9F FC，毕竟*a拆包a得到9F和FC，4个9F和FC就是上面的样子了。只有[a]得到[['9F', 'FC']]再拆包时得到['9F', 'FC']，乘上4才是4个小数组
sets = [''.join(x) for x in itertools.product(*[a] * b)]
#第三步：字典爆破
for j in range(15):
    #每一个sets[j]形如9F9F9FFC，ps是p按照FC分割后的数组。每一个FC处都有两种可能，原来是9F被替换成了FC，或是本来就是FC，无需替换。sets就是遍历了所有的可能，爆破拼接出原来的p
    np = ps[0] + sets[j][0:2] + ps[1] + sets[j][2:4] + ps[2] + sets[j][4:6] + ps[3] + sets[j][6:8] + ps[4]
    np1 = int(np, 16)
    #如果n可以被np1整除，则得正确解。
    if (n % np1 == 0):
        break

#TODO：正常的RSA解密
q = n // np1
phi = (q - 1) * (np1 - 1)
d = gmpy2.invert(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m))
```

[itertools.product()](https://blog.csdn.net/The_Time_Runner/article/details/90143662)和python的[解包](https://zhuanlan.zhihu.com/p/41968260)操作。

## Flag
> flag{I_w1ll_us3_OTp_n3xT_T1M3}