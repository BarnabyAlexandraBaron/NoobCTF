# RSA1

[题目地址](https://buuoj.cn/challenges#RSA1)

不说废话的rsa题。扫了一眼附件，天真地以为又是送分题，c，p和q都给了，不是送分是什么？再一看，哦，没有e，只有dp和dq。这就不得不寻求[wp](https://blog.csdn.net/qq_32350719/article/details/102719279)的帮助了。

脚本很简单，最后放，关键是理解数学证明。现在的我不同往日，已经学过模运算了，是时候看看自己学的好不好了。

c≡$m^e\mod n$
m ≡ $c^d \mod n$
ϕ(n)=(p−1)∗(q−1)
d∗e≡1 mod ϕ(n)
dp≡d mod (p−1)
dq≡d mod (q−1)

以上是已知条件，目的是得到m，或者说$c^d$。之前做过类似的题，利用中国剩余定理可以得到:

m1≡$c^d\mod p$,m2≡$c^d\mod q$

当时一直不理解怎么得的，今天总算是知道一点了。由$m≡c^{d} \mod n$,可以得到式子$m=c^{d}+k∗n$；又因为n=p∗q，所以可以得到$m=c^{d}+p∗q∗k$。两边取余p得到$m = c^{d}+q∗k$,两边取余q得到$m = c^{d}+p∗k$。这个式子像什么呢？这不跟最开始$m=c^{d}+k∗n$式子长的很像吗？因此把m mod p写为m1，m mod q写为m2，得到$m1≡c^d \mod p$,$m2≡c^d \mod q$。

带入上面的公式，可以得到$c^{d}=kp+m1$。最开始纠结$m1=c^{d}+q∗k$，那应该是$c^{d}=m1-q∗k$啊，怎么是加呢？后来思考平时解密时的步骤，$c^d \equiv m\mod n$，d一般很大，$c^d$肯定要比m大，根据$m=c^d+kn$，相应的k就是负数了，于是得到作者的式子。继续往下。

把式子代入$m2≡c^d \mod q$可以得到m2≡(kp+m1) mod q。等式两边同时减去m1,可以得到(m2−m1)≡kp mod q(m2−m1)≡kp mod q。这里因为gcd(p,q)=1，可以求p的逆元，得到$(m2−m1)∗p^{−1}≡k \mod q$,至此得到以下式子：

$k≡(m2−m1)∗p^{−1} \mod q$<Br>
$c^{d}=kp+m1$

将上下两个式子合并，得到：

$c^d=((m2−m1)∗p^{−1}\mod q)∗p+m1$

最后带入$m≡c^{d} \mod n$,得到$m≡(((m2−m1)∗p^{−1} \mod q)*p+m1) \mod n$。很好，但是m1和m2去哪里找？当然是自己推出来了。首先需要了解费马小定理：

$a^{{p-1}}\equiv 1{\pmod  {p}}$

然后变换一下最上面的已知条件，得到d=dp+k∗(p−1)（这里和上面变换方式一模一样，k也是负数），代入$m2 = c^{d}+p∗k$，得到$m2≡c^{dp+k∗(p−1)}\mod p$,幂运算直接拆开成$m2≡c^{dp}∗c^{k∗(p−1)}\mod p$。现在不就可以用费马小定理了吗？c肯定是质数，且gcd(c,p)=1，于是有$c^{(p−1)}≡1\mod p$。又因为$c^{k∗(p−1)}$等于${(c^{(p−1)})}^k$,根据模运算规律,如果$a\equiv b\mod p,c\equiv d\mod p$，那么$ab\equiv cd \mod p$。${(c^{(p−1)})}^k$等同于k个$c^{(p−1)}$相乘，每个模p都与1同余，乘在一起与k个1相乘同余。证得$c^{k∗(p−1)}≡1\mod p$。

折腾一圈得到$m2≡c^{dp} \mod p$,m1用相似的方法得到$m1≡c^{dq}\mod q$。最终得到：

$m1≡c^{dq }\mod q$<br>
$m2≡c^{dp} \mod p$<Br>
$m≡(((m2−m1)∗p−1 \mod q)*p+m1) \mod n$

```python
from Crypto.Util.number import *
p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 
q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 
dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 
dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 
c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852
invq=inverse(p,q)
mp=pow(c,dp,p)
mq=pow(c,dq,q)
m=((mp-mq)*invq%p)*q+mq
print(long_to_bytes(m))
```

嗯我的模运算基础合格了。这题很坑的一点是输出不是flag，要把前缀换成flag。

### Flag
- flag{W31c0m3_70_Ch1n470wn}