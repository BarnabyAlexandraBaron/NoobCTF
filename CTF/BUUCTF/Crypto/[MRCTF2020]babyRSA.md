# [MRCTF2020]babyRSA

[题目地址](https://buuoj.cn/challenges#[MRCTF2020]babyRSA)

比纸老虎还纸老虎的题目仍然吓跑了我。

```python
import sympy
import random
from gmpy2 import gcd, invert
from Crypto.Util.number import getPrime, isPrime, getRandomNBitInteger, bytes_to_long, long_to_bytes
from z3 import *
flag = b"MRCTF{xxxx}"
base = 65537


def GCD(A):
    B = 1
    for i in range(1, len(A)):
        B = gcd(A[i-1], A[i])
    return B


def gen_p():
    P = [0 for i in range(17)]
    P[0] = getPrime(128)
    for i in range(1, 17):
        P[i] = sympy.nextprime(P[i-1])
    print("P_p :", P[9])
    n = 1
    for i in range(17):
        n *= P[i]
    p = getPrime(1024)
    factor = pow(p, base, n)
    print("P_factor :", factor)
    return sympy.nextprime(p)


def gen_q():
    sub_Q = getPrime(1024)
    Q_1 = getPrime(1024)
    Q_2 = getPrime(1024)
    Q = sub_Q ** Q_2 % Q_1
    print("Q_1: ", Q_1)
    print("Q_2: ", Q_2)
    print("sub_Q: ", sub_Q)
    return sympy.nextprime(Q)


if __name__ == "__main__":
    _E = base
    _P = gen_p()
    _Q = gen_q()
    assert (gcd(_E, (_P - 1) * (_Q - 1)) == 1)
    _M = bytes_to_long(flag)
    _C = pow(_M, _E, _P * _Q)
    print("Ciphertext = ", _C)
'''
P_p : 206027926847308612719677572554991143421
P_factor : 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839
Q_1:  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521
Q_2:  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743
sub_Q:  168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651
Ciphertext =  1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832
'''
```

刚看到这题的我真的头疼，啥东西啊，给了这么多乱七八糟的玩意。一看[wp](https://blog.csdn.net/m0_52727862/article/details/118798253)，我傻了，真的傻了。这题看似复杂，给了一些函数，仔细研究一下就发现根本不用自己推。

gen_q函数生成了3个1024位的质数，然后用这三个质数通过`Q = sub_Q ** Q_2 % Q_1`表达式生成了Q。根据`return sympy.nextprime(Q)`，gen_q的结果是Q的下一个质数。题都没看完的我觉得有点难啊，给了3个质数还有模运算，怎么搞呢？实际上难个鬼啊，Q_1，Q_2和sub_Q已经给了，直接照着它做不就完事了吗？

gen_p会不会复杂一点呢？函数内部有个P列表，`P[0]`是一个128位的质数，然后接下来的`P[i]`等于`sympy.nextprime(P[i-1])`。先不要急着下结论难不难，看看题目提供了什么信息。给出了P_p，或者说`P[9]`，嗯……有个其中一个质数不就能用sympy.prevprime推回去了吗？现在P列表可以说是已知数了，再往下看知道P列表中每个质数乘起来得到一个n，然后又生成一个质数p，通过最后的`sympy.nextprime(p)`可以知道，如果已知p的值，就能得到生成的p。不过这次没那个直白了，给出的是P_factor，而P_factor等于pow(p, base, n)。base上面写了，65537。等一下这不就是普通的rsa了吗，只不过n是十几个质数的乘积，求toitent时多来几步就好了。利用base和n的toitent求出逆元，最后就和一般的rsa一样了。

```python
import gmpy2
import sympy
base = 65537

P_p=206027926847308612719677572554991143421
P_factor=213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839
Q_1=103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521
Q_2=151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743
sub_Q=168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651
Ciphertext=1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832

q=sympy.nextprime(gmpy2.powmod(sub_Q,Q_2,Q_1))
P=[]
for i in range(9):
    P_p=sympy.prevprime(P_p)
P.append(P_p)
for i in range(1,17):
    P.append(sympy.nextprime(P[i-1]))
n=1
phi=1
for i in range(17):
    n*=P[i]
    phi*=(P[i]-1)
based=gmpy2.invert(base,phi)
_p=gmpy2.powmod(P_factor,based,n)
p=sympy.nextprime(_p)
d=gmpy2.invert(base,(p-1)*(q-1))
plaintext=gmpy2.powmod(Ciphertext,d,p*q)
import binascii
print(binascii.unhexlify(hex(plaintext)[2:]))
```

## Flag
> flag{sti11_@_b@by_qu3st10n}