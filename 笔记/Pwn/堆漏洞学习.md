# 堆漏洞学习

### [unlink](https://github.com/JnuSimba/LinuxSecNotes/blob/master/Linux%20X86%20%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97/Unlink%E5%A0%86%E6%BA%A2%E5%87%BA.md)

##### 2.2 开始攻击

......

假设被覆盖后的chunk header相关数据如下：

prev_size =一个偶数，这样其PREV_INUSE位就是0了，即表示前一个chunk为free。
size = -4
fd = free函数的got表地址address – 12；(后文统一简称为“free addr – 12”)
bk = shellcode的地址
那么当程序在[4]处调用free(first)后会发生什么呢？我们一步一步分析。
一、向后合并
鉴于first的前一个chunk非free的，所以不会发生向后合并操作。
二、向前合并
先判断后一个chunk是否为free，前文已经介绍过，glibc malloc通过如下代码判断：

![heapunlink](../images/heapunlink4.jpeg)

PS：在本例中next chunk即second chunk，为了便于理解后文统一用next chunk。

从上面代码可以知道，它是通过将nextchunk + nextsize计算得到指向下下一个chunk的指针，然后判断下下个chunk的size的PREV_INUSE标记位。在本例中，此时nextsize被我们设置为了-4，这样glibc malloc就会将next chunk的prev_size字段看做是next-next chunk的size字段，而我们已经将next chunk的prev_size字段设置为了一个偶数，因此此时通过inuse_bit_at_offset宏获取到的nextinuse为0，即next chunk为free！既然next chunk为free，那么就需要进行向前合并，所以就会调用unlink(nextchunk, bck, fwd);函数。真正的重点就是这个unlink函数！

和栈一样，堆也可以溢出。处于使用状态的堆中的fd和bk部分用于存储用户数据，那这块区域肯定就是提前计划好的。假设这块为16个字节，但往里面存了超过16个字节的数据，那么数据就会溢出到chunk header（来自未来的我：似乎溢出到了下一个堆块的chunk header，而不是自己的）。上面的例子中将覆盖的内容精心布置，这种精心布置的理解和栈溢出一样，都是利用了堆的结构和程序特性来实现攻击。

一定要看每张图里的代码和注释，是有用的。比如unlink函数的参数是在前面的图中的注释里有提到，unlink(P,BK,FD)的p指向malloc_chunk的结构体，BK是bck，FD是fwd，它们分别是当前chunk向后和向前一个free chunk。

......

此时P = nextchunk, BK = bck, FD = fwd。
1)首先FD = nextchunk->fd = free地址– 12;
2)然后BK = nextchunk->bk = shellcode起始地址；
3)再将BK赋值给FD->bk，即（free地址– 12）->bk = shellcode起始地址；
4)最后将FD赋值给BK->fd，即(shellcode起始地址)->fd = free地址– 12。
前面两步还好理解，主要是后面2步比较迷惑。我们作图理解：

![heapunlink5](../images/heapunlink5.png)

结合上图就很好理解第3，4步了。细心的朋友已经注意到，free addr -12和shellcode addr对应的prev_size等字段是用虚线标记的，为什么呢？因为事实上它们对应的内存并不是chunk header，只是在我们的攻击中需要让glibc malloc在进行unlink操作的时候将它们强制看作malloc_chunk结构体。这样就很好理解为什么要用free addr – 12替换next chunk的fd了，因为(free addr -12)->bk刚好就是free addr，也就是说第3步操作的结果就是将free addr处的数据替换为shellcode的起始地址。

由于已经将free addr处的数据替换为了shellcode的起始地址，所以当程序在代码[5]处再次执行free的时候，就会转而执行shellcode了。

至此，整个unlink攻击的原理已经介绍完毕，剩下的工作就是根据上述原理，编写shellcode了。只不过这里需要注意一点，glibc malloc在unlink的过程中会将shellcode + 8位置的4字节数据替换为free addr – 12，所以我们编写的shellcode应该跳过前面的12字节。

这段我理解了好久，什么叫“将它们强制看作malloc_chunk结构体”？看这篇文章需要C语言基础，但是我没有啊，于是搜到了[相关内容](https://blog.csdn.net/blog_xu/article/details/84374473)。是可以把一段连续的内存（比如后文提到的全局数组，不知道我这么理解对不对？）对应着转换成结构体的每一个成员的。这大概就是(free addr -12)->bk是free addr的原因了（按照堆块的结构，中间有3个字段，每个4字节，也许吧，我这个能力只能找到这个解释了）。

好消息：上面那段花了好久明白后你会发现：那个技术早就已经过时了=(。没关系，脑洞大开的黑客们总能想办法。

“如何利用”那个小节可以解答很多疑惑，果然来个例子就清晰很多了，而且还是绕过损坏双链表防御的方法。关键点在于用用户数据部分（fd和bk）伪造了整个堆块的结构，然后溢出到下一个堆块瞒天过海，两者配合欺骗glibc。

### [Fastbin Attack](https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/fastbin-attack/)

##### Fastbin Double Free

这个在pwn堆中用得很多，不会就吃席。而且大部分都属于入门级别堆题，虽然堆的入门级别已经比ret2libc还要难得多。

fastbin attack的关键在于堆溢出，或者别的能控制chunk内容的东西，例如uaf。这里说的chunk内容不是chunk的user data域，而是fd，bk这类平时接触不到但是又和chunk息息相关的东西。拿stack的pwn类比，正常来说用户输入不可能碰得到ebp，eip这种东西，但是ebp和eip又和栈的执行息息相关。在栈上我们通过溢出构造rop链，本质上就是理解并利用了栈的结构，现在到堆了也是一个道理。

fastbin attack有这些分类：

·Fastbin Double Free

·House of Spirit

·Alloc to Stack

·Arbitrary Alloc

前两种漏洞侧重于利用 free 函数释放真的 chunk 或伪造的 chunk，然后再次申请 chunk 进行攻击，后两种侧重于故意修改 fd 指针，直接利用 malloc 申请指定位置 chunk 进行攻击。说这些肯定没法懂，研究原理。

搞fastbin attack不懂fastbin寸步难行。fastbin使用单链表维护制定大小内被释放的堆块，并且由 fastbin 管理的 chunk 即使被释放，其 next_chunk 的 prev_inuse 位也不会被清空。假设我们有3个chunk，都是fastbin大小，free chunk1会让chunk1加入fastbin的单链表，fd 是0x000000，代表没有前一个堆块；free chunk 2会让chunk 2的fd指向chunk 1；free chunk3会让chunk 3的fd指向chunk 2。就是排队，太好理解了。

这样看来fastbin malloc时的顺序也很简单了。假如malloc的大小和已有的一致，比如chunk 3，那就会把chunk 3从链表中拿出去；然后chunk 2；最后chunk 1。先进后出。现在有个问题，你说同一个chunk能不能排两次队？答案是可以。这主要因为以下两个问题：

1. fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空
2. fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。

pre_inuse不清空让系统不知道前面的堆块是不是已经被使用了；不做验证更是给了double free的温床。试想这个场景，有chunk1和chunk2，先free chunk1，然后再free chunk1，会出现问题吗？答案是会，因为链表头部还是会验证的，chunk1在此处就是fastbin的链表头部。于是我们以第一步为基础，再free chunk2，现在在free chunk1会报错吗？这回就不会了，因为现在的链表头部是chunk2了。double free chunk1会导致一个问题，同一个chunk排了两次队。

main_arena->chunk1->chunk2->chunk1

本来chunk1是第一个chunk（这个第一个指的是第一个进入链表的chunk），因此fd是0；现在它又来排队了，fd理所当然就成了chunk2。前面说过，fastbin attack的前提是能修改堆块结构，如果我们把chunk1的fd改了就能实现任意地址分配 fastbin 块。比如这个例子。

```c
typedef struct _chunk
{
    long long pre_size;
    long long size;
    long long fd;
    long long bk;
} CHUNK,*PCHUNK;

CHUNK bss_chunk;

int main(void)
{
    void *chunk1,*chunk2,*chunk3;
    void *chunk_a,*chunk_b;

    bss_chunk.size=0x21;
    chunk1=malloc(0x10);
    chunk2=malloc(0x10);

    free(chunk1);
    free(chunk2);
    free(chunk1);

    chunk_a=malloc(0x10);
    *(long long *)chunk_a=&bss_chunk;
    malloc(0x10);
    malloc(0x10);
    chunk_b=malloc(0x10);
    printf("%p",chunk_b);
    return 0;
}
```

前面几个malloc和free只是构造一个上面提到的链表。其实我有一点不懂改chunk_a的地址为bss_chunk怎么就改了fd了呢？还好一般题目不是这样改的，溢出改的居多。第一次malloc chunk_a，得到的指针和chunk1一致。更改chunk_a等同于更改chunk1的fd。不过这次更改不会影响下次malloc，毕竟链表在更改之前就按照fd把链表尾设为chunk2了。于是第二次malloc得到chunk2。同理，第三次malloc得到chunk1。这时候问题来了，我们知道fastbin指定链表尾是根据fd的，chunk1的fd是什么？bss_chunk，之前设置的。于是最后一次malloc成功得到想要地址的chunk，攻击完成。

值得注意的是，我们在 main 函数的第一步就进行了bss_chunk.size=0x21;的操作，这是因为_int_malloc 会对欲分配位置的 size 域进行验证，如果其 size 与当前 fastbin 链表应有 size 不符就会抛出异常。这是个小贴士，如果因为种种原因要分配的chunk的size不对，需要先改一下才能攻击。

通过 fastbin double free 我们可以使用多个指针控制同一个堆块，这可以用于篡改一些堆块中的关键数据域或者是实现类似于类型混淆的效果。 如果更进一步修改 fd 指针，则能够实现任意地址分配堆块的效果 (首先要通过验证)，这就相当于任意地址写任意值的效果。

##### House Of Spirit

