# 数论学习

我又来学数论了，因为抽象代数真的太难了，英语又差，听又听不懂，学也学不好。撑了一会还是决定放弃转数论。使用这个[课程](https://www.youtube.com/watch?v=EzE6it9kAsI&list=PL8yHsr3EFj53L8sMbzIhhXSAOpuZ1Fov8)，仍然和学群论时是一个教授。虽然我群论啥也没听懂，但是听不懂数学顶级教授的课绝对是我太菜的问题。现在开始吧。

## Introduction to number theory

说到数论不得不提到质数。先介绍一种名叫Eratosthenes的方法。这个方法非常简单粗暴，把所有数字写在一张纸上，然后排除一定不是质数的0和1，于是第一个质数是2。接着把之后所有是2的倍数的数字全部划掉，它们不可能再是质数了。划完后找下一个没有被划掉的数字3，圈起来并继续划掉3的倍数。下一个圈起来的数是5……如此往复找质数就很容易了。但是一共有多少个质数呢？由此牵扯到数论的第一个定理：质数的数量是无限的。

这最早由Euclid提出，不过他最开始不是这么说的。希腊人不喜欢“无限”的概念，于是他换了一种说法：取有限的质数$P_1...P_n$，可以找到另外一个不在此集合中的质数。他求出这些质数的乘积后加1，$P_1*P_2*...*P_n+1$，然后找到这个数的一个素数因子$P_{n+1}$。会发现这个素数因子不可能在已有的质数集合$P_1...P_n$中，因为在已有的质数集合中的质数无论如何都不可能整除于其乘积+1。由此得出$P_{n+1}$是一个新质数。

![find_primes](../images/find_primes.png)

上图展示了这一流程。注意所有已知质数的乘积+1不一定是一个质数，比如最后一步。目前我们有了找质数的稳定方法，可是这个方法生成的质数不一定一个比一个大，怎么找大质数呢？有种Mersenne质数，其形如$2^n-1$。试一下，$2^2-1=3,2^3-1=7,2^4-1=15=3*5$,不对啊，这哪是质数？确实不是，因为使用的n不是质数。$2^{ab}-1=(2^a-1)*(2^{ab-a}+...+1)$，会被$2^a-1$整除。好，从现在开始我们只取n为质数，$2^5-1=31,2^4-1=127,2^11-1=2047=23*199$。又不是质数了。没错这个方法就是这样，虽然$2^n-1$，n为质数时很多时候都是质数，不过总有一些例外。其实也是个不错的生成质数的方法了。不过这个方法可以一直用吗？换句话说，是否有无数多个Mersenne质数？这个问题目前还没有被解决，所以我就等着各位在国际数学界一展风采了:D

另一种长得很像的质数是费马质数，形如$2^n+1$。$2^0+1=2,2^1+1=3,2^2+1=5,2^3+1=9=3*3$。这个不是质数，因为当$2^{ab}+1$的a是奇数时，整个式子整除$2^a+1$。为了防止这种情况发生，我们可以取这种质数，$2^{2^m}+1$。$2^{2^0}+1=3,2^{2^1}+1=5,2^{2^2}+1=17,2^{2^3}+1=257,2^{2^4}+1=65537$。这些数都被称为费马质数。费马曾经以为所有形如$2^{2^m}+1$构建的数都是质数，但是$2^{2^5}+1$整除641。我们都知道费马也算数学界的传奇人物了，这个小错误完全有可能是因为他算错了，就这么朴实无华。至于费马质数的应用，你会在一个八杆子打不着的地方发现它们的身影——哪些正多边形可以只用尺子和圆规来构造？高斯发现如果一个数是费马质数，那么就可以。甚至说，所有你可以只用尺子和圆规来构造的多边形都是不同的费马质数于2的幂的乘积。人们往后推了几个情况，都没有再发现新的费马质数。关于费马质数是否有无限多个的问题仍然值得探讨，不过我们可以笃定，费马提出的这种方法并不是那么容易找质数。

到底有没有简单的方法来生成大质数？比如一个多项式f(n),结果永远是质数。这个多项式不能是f(n)=3这种无聊的玩意，即不能为常数项。欧拉找到一个，$n^2+n+41$，然而仅适用于41之前的情况。当n=41时，整个多项式自然就能整除41了。事实证明这样的多项式不存在。让$f(n)=an^k+...+bn+c$，假如常数项c大于1，那么在n=c时f(n)绝对整除c，毕竟整个式子每一个项都是c的倍数。说明常数项只能等于1。但是常数项等于1时我们可以将$f(n)$转为$f(n+j)$，让常数项不等于1，重复刚才的论点。至此我们知道没有非平凡的多项式能永远生成质数。甚至说，人们到现在还没有找到能稳定生成质数的捷径，搞到最后第一种看起来傻瓜的方法竟然是最好用的。

看了这么久“是否有无限质数”，不如把目光放到有限的世界上来。有多少小于x的质数？这个问题可以用$\Pi(x)$表示，此处的$\Pi$不是3.14159那个，而是希腊字母里表示P的字母。正如无法找到永远生成质数的多项式，我们也无法准确知道$\Pi(x)$的值，但是我们可以粗略估计。高斯提出了一个式子，$\Pi(x)\cong \frac{x}{log(x)}$。注意在数学的世界里，log总是代表以e为底的对数。这个式子直到19世纪才被证明，高斯确实牛逼。用不正规的理解就是，n是质数的几率大概为$\frac{1}{log(n)}$。你可能会觉得，n要么就是质数，要么不是，怎么还有机率的？说n是质数的机率是xxx多少有点毛病。也对，这就靠意会了。

这个公式可以应用于刚刚提到的Mersenne质数：Mersenne质数的数量是无限的吗？按照公式和Mersenne质数的定义，$\frac{1}{log(2^n-1)}=\frac{k}{n}$,这是其中一个Mersenne数是质数的机率。把所有机率加起来，$\sum_n \frac{k}{n}=k(1+\frac{1}{2}+\frac{1}{3}+...)=\infin$，微积分经典调和级数，和为无限，那一共就有无限个Mersenne质数？有点问题，这个论点假设Mersenne质数是随机的，可是它们显然不是，都是$2^n-1$结构的。更离谱的问题在于，当我们拿同样的方法找形如$2^n-2$的数中有多少是质数时，结果应该也是无限个。这不是在搞笑吗，$2^n-2$明显整除2，除了n=2的情况时是个质数。所以这种机率只能用做一个方向指导，实际证明时要谨慎使用，你不知道能搞出来什么幺蛾子。这也是数论中的一个经验法则，所有用上概率参数的证明都非常简单，然而完全不严谨，还有可能给出错误答案，基本没用。

到底有多不严谨和模糊呢？拿费马质数举例子。$2^{2^n}+1$，$\sum \frac{1}{log(2^{2^n}+1)}\approx k\frac{1}{2^n}<\infin$。这说明费马质数的数量应该是有限的。但是我们换种说法，$2^n+1$,$\sum \frac{1}{log(2^n+1)}\approx k\frac{1}{n}=\infin$,这回又有无限多个了。两种形式都是费马质数，所以到底哪个是对的？谁也不知道。

另一位数学家同样发现了求小于x的质数的数量的公式$Li(x)=\int^x_0\frac{1}{log(x)}dx$。此处的等于号并不是完全等于，有“大概”的意思，因为当x=1时，整个积分是发散的。黎曼更是有特别的想法，既然数质数这么难，不如我们数质数幂吧？$p^n$应该算作质数的$\frac{1}{n}$。由此有定义$\Pi'(x)=$小于x的质数幂数量($p^n$算作$\frac{1}{n}$)。黎曼真的找到了这个式子，$Li(x)-\sum_\rho Li(x^p)$。接着我们知道$Li(x)\approx \frac{x}{log(x)}$，这也能解释上一个数学家的式子是哪里来的了。很神奇的地方是，$\Pi'(x)$明显为一个非连续函数，但是它竟然可以用一系列连续函数的和表示。sum使用的$\rho$不是p，这在数学中一般表示一个变量，这里特别表示[zeta函数](https://zh.wikipedia.org/wiki/%E9%BB%8E%E6%9B%BC%CE%B6%E5%87%BD%E6%95%B8)的零项(zeros of zeta function)。

我表示还是不懂$\rho$是什么东西。首先要知道zeta函数长啥样：$\Zeta(s)=\frac{1}{1^s}+\frac{1}{2^s}+\frac{1}{3^s}+...$，$\rho$就是满足$\Zeta(\rho)=0$条件的数。

似乎有点困难，温习算术基本定理来休息一下。任何大于等于1的整数都可以以独特的方式表达为素数的乘积。这在zeta函数中有使用，欧拉发现$\frac{1}{1^s}+\frac{1}{2^s}+\frac{1}{3^s}+...+\frac{1}{90^s}=\frac{1}{1-2^{-s}}\frac{1}{1-3^{-s}}\frac{1}{1-5^{-s}}...$，这是所有质数的积。乍一看觉得很神奇，不过把式子写成级数后就很容易了。$(1+\frac{1}{2^s}+\frac{1}{4^s}+\frac{1}{8^s}...)(1+\frac{1}{3^s}+\frac{1}{9^s}...)(1+\frac{1}{5^s}+...)$，把原式每一项写为一个级数之和，然后取出每个级数的一个项相乘。比如在第一个级数中取$\frac{1}{2^s}$,第二个级数中取$\frac{1}{9^s}$,第三个级数中取$\frac{1}{5^s}$，剩下的级数都取1，就得到了$\frac{1}{2^s}*\frac{1}{(3^s)^2}*\frac{1}{5^s}=\frac{1}{2*3^2*5}=\frac{1}{90}$。不难猜测第一个式子中的每一项都可以由无限级数乘积中的独特组合来表示，正是因为任何整数都能以唯一的方式写成素数幂的乘积。这个神奇的分解是欧拉给出的，他还将第一个式子用来证明质数有无限多个。取s=1，第一个式子就成了简单的调和级数，和无限，发散。既然第一个式子是无限的，第二个式子的素数乘积必然也是无限的。如果不是，其乘积一定是非0有限数，不可能等同于第一个式子的无限，因此素数的数量是无限多个。

接下来看看丢番图方程（Diophuntine equations)。此类方程专注于找整数解，最著名的一个莫过于$x^2+y^2=z^2$，勾股定理；线性方程同样很常见，$27x+11y=1$；二次方程总不可能被排除,$2x^2=y^2$。这个方程变换一下相当于问$\frac{y}{x}=\sqrt{2}$，根号2是有理数吗？换句话说，证明这个式子没有非0整数解等同于证明根号2不可能是有理数。还是很好解的，根据方程可以看出y一定是偶数，因为左项很明显就是偶数，如果是奇数就不可能有整数解了。两边同时除以2，得到$x^2=\frac{y^2}{2}$，又出现了一个满足原方程的解。如果一个方程有解，那一定会有一个最小解，但是这么除下去没有个头，只能说明原方程根本无解。很经典的一个证明方法，[无穷递降法](https://zh.m.wikipedia.org/zh-cn/%E6%97%A0%E7%A9%B7%E9%80%92%E9%99%8D%E6%B3%95)。

气氛都到这里了不介绍一下“臭名昭著”的费马大定理我不是很认可。$x^n+y^n=z^n$，要求n大于等于3，x，y，z都是非0项。自从费马家的书空白页太少，这个问题就一直是数学界最著名的问题之一。直到1990年被Wiles证明。这有很多变种，比如$x^4+y^4+z^4=z^4$，你能看出来这个方程有没有解吗？答案是有，就是有亿点大。判断一个丢番图方程有没有解很困难，要么难以证明无解，要么有解但是很大，简直太难找了。不禁让人想问个问题：有没有一种算法可以解出所有丢番图方程？比如f(x,y,z...)，算法会直接告诉你无解或者给出解。然而是不可能的，已经有人证明了。

最后一种介绍的丢番图方程是[佩尔方程](https://zh.wikipedia.org/wiki/%E4%BD%A9%E5%B0%94%E6%96%B9%E7%A8%8B)……的变种。形如$x^2=Dy^2\pm 1$，比如$x^2=94y^2+1$。佩尔方程邪恶的地方在于看起来人畜无害的小系数最后可能会有大得离谱的解。

## Survey

暂时不知道这集的名称survey是什么意思，但是我知道要从模的同余开始。模的应用非常广泛，比如$1234567=x^2$有解吗？这题太简单了，没有，因为任何一个平方数的个位只能是$0^2,1^2,2^2...9^2$的个位，即0，1，4，9，6，5，6，9，4，1之间的一个，7不是，自然就不可能是平方数了。这涉及到模10的同余,同余记做$a\equiv b\mod m$，意味着a-b整除于m。$1，2，3，4，5，6，7\equiv 7\mod 10$，$x^2\not\equiv 7 \mod 10$。

有了同余这一利器，我们可以解决更复杂的问题。$1000003=x^2+y^2$是否有解？倒是可以一个一个试，但是有简单方法不用不是傻子吗？$x^2\equiv 0,1\mod 4,x^2+y^2=(01)+(01)=0,1,2\mod 4$，然而1000003模4不与0，1，2同余，故无解。至于为什么选模4，教授没有明说，个人觉得选别的也行，只要模的结果好算就得了。1000003模4一眼就看得出来是3，模10应该也是可以得出来一样的结论的。

说到同余怎么能不带费马小定理玩？当p为质数时，$x^p\equiv x\mod p$，另一种形式是$x^{p-1}\equiv 1\mod p$。欧拉也有一个很像的定理，当x，m互质时，$x^{\phi(1)}\equiv 1\mod m$。$\phi$是一个函数，$\Phi(m)=$1,...m-1中与m互质的数的数量。这两个定理堪称数论的基石，非常有用也不是很难。比如在n很大时，用于测试n是否是一个质数。使用费马小定理，验证$2^n\equiv 2\mod n$？如果不满足，n绝对不是一个质数；如果满足，n也许是一个质数。满足的情况如果想进一步验证，可以将底数2换成别的继续试。同余还能和丢番图方程扯上关系。如果f(x,y,z)=0，那么$f(x,y,z)\equiv 0\mod m$。这表示如果我们能以整数解的形式解出f(x,y,z)=0这样的多项式，那么任意找一个m都能满足同余条件。Hasse定理大概是其逆定理，不过不完全正确。对于线性方程大多数情况下逆定理成立，然而更高次的方程就不太行了。

看一个基础的二次方程，$x^2\equiv a\mod p$。这里的a也叫二次剩余。当p=7时，$0^2=0,1^2=1,2^2=4,3^2=9\equiv 2,4^2=16\equiv 2...$，能看出a的可能值只有0，1，2，4。有一个很好玩的符号，$(^a_p)$，当a是p的二次剩余时等于1，不是时等于-1，a能被p整除时等于0。二次剩余很重要的一个定理是二次互反律（quadratic reciprocity）：p,q都为质数时，$(^p_q):(^q_p)$之间有某种神奇的关系。如果$x^2=p+qy$有解，$(^p_q)$为1；如果$x^2=q+py$有解，$(^q_p)$为1。这俩方程很像，但好像真没别的联系了……吗？欧拉发现，当q或者p中有一个模4与1同余，则$(^p_q)=(^q_p)$;当p，q模4都与3同余时，$(^p_q)\not =(^q_p)$。这恰恰说明两个式子之间有着奇妙的联系。

练习一下新学的二次互反律吧。3是71的二次剩余吗？我们将描述转换成方程的形式，$x^2\equiv 3\mod 71$,问题就变成了更数学的问题：$(^3_{71})=1$?又根据二次互反律，等同于问$(^{71}_3)=1$?可是无论是3还是71，它们模4都和3同余，只能是相反的情况。$71\equiv 2\mod 3$，2不是一个平方数，所以$(^{71}_3)=-1$。既然两者相反，原问题$(^3_{71})=1$。

现在让我们放宽视野，粗略认识数论的一个分支：加法数论（additive number theory)。论如其名，这是个讨论把东西加在一起会发生什么的分支。一个著名的问题goldback：是否所有大于等于4的偶数都是2个质数的和？比如12=5+7，14=7+7，16=5+11...这个问题非常难解决，有两位数学家证明了它的弱化版本——任何足够大的奇数都是3个素数的和。时间再往后推一点，又有一位数学家证明了其没那么弱化的版本——每个偶数都可以写为p+qr的形式，p，q，r都是质数。两个质数的乘积和单纯质数很接近了，然而还是弱化版本，这也是人类目前为止在这个领域的所有进展。另一个相似的未解之谜是孪生素数（twin prime）问题：在p为质数的前提下，是否能找到无限个形如p，p+2的质数？目前数学家们倒是证明了p，p加上几百的情况，可惜离2还有很长的路要走。以及素数的算术级数（arithmetic progressions)问题。一个素数算术级数的例子是5，11，17，23，29，长度为5，差为6。问题在于你能找到任意长度的算术级数吗？在你还没开始想之前，狄利克雷再甩给你一个问题：对形如a+nb的数取其算术级数，比如1+10n，要求所有个位为1的数。证明在任意算术级数中都有无限多个素数，当然a，b互质。

狄利克雷的问题其实是下面这个一般定理在1次时的特例($a_0+a_1n$,能随意拆）。有多项式$a_0+a_1n+a_2n^2+...$，这个多项式是否表示了无限多个质数？$n^2+n=n(n+1)$的情况肯定不行，除了某些特殊的n值外，原多项式可以被因式分解，分解了不就很明显不是质数了吗？因此我们还要加个限制，多项式不能被因式分解。结果还是不行，$n^2+n+4$不会被分解，但是$n^2+n$明显是个偶数，偶数加偶数还是偶数，整个多项式总是偶数，更不可能是质数了。那我们就直接假设当算术级数不能被分解，无法整除大于1的数时，是否能表示无限数量的素数？$n^2+1$看起来满足这些要求，却也掩盖不了$8^2+1=65$不是质数的事实。这个问题目前无人解答，学到这里这么多未解之谜出现了你不去试一下？

试完了吗？有点累？那推荐给你休闲数论（recreational number theory），下班放学休闲必备。完美数（perfect number）代表所有因数之和是本身的数。6=1+2+3，28=1+2+4+7+14。休闲数论的创始人很会取名字，诸如友好数字（amicable numbers）。220和284是一对友好数字，220的所有真除数（proper divisor）相加等于284，284的所有真除数相加等于220。真除数指的是小余被除数的除数，这个除数必须整除于被除数且是正整数。比如20的5个真除数是1，2，4，5，10。玩了一会休闲数论，你的灵魂一定会问你：“啊这有什么用吗？”也许跟其他分支比起来就是没有用，但是休闲，不就是玩吗，玩要什么意义呢？ᶘ ᵒᴥᵒᶅ

代数数论（algebraic number theory）。一个很经典的代数例子是复数m+ni，$i=\sqrt{-1}$。这类数字被称为高斯整数（Gaussian ints），和普通整数很相似，比如它们都可以被拆分为独特的质数之积。不过高斯整数的质数就不是5什么的了，因为5=(2+i)(2-i)。这么看下来高斯整数简直太适合处理两个平方的和了，$(m+ni)(m-ni)=m^2+n^2$。平时熟悉的数也可以用奇奇怪怪的方式分解，$65=8^2+1^2=7^2+4^2=(8+i)(8-i)=(7+4i)(7-4i)$，进一步分解还能得到(2+i)(2-i)(3+2i)(3-2i)，最后一种是高斯整数的素数分解方式。费马继续来插一脚，如果p是质数，$p\equiv 1\mod 4$，则$p=n^2+m^2$。

最后看一下组合数论（combinatorial number theory）就收工。n的partition表示所有能将n写为更小的正整数的和的形式的数量。$p(n)=a_1+a_2+a_3$。我真不懂这个怎么表达，看例子。5=5=4+1=3+2=3+1+1=2+2+1=2+1+1+1=1+1+1+1+1,一共7种，所以p(5)=7。尝试证明这个定理：p(5n+4)整除5。一定要试试，因为教授说大概率做不出来ʕ •ᴥ•ʔ

## Divisibility and Euclid's algorithms

定义a|b为a整除于b，或者说b=xa，对于某些整数x。根据这个特性，a|0是板上钉钉的事，但是0|a是不可能的，除非a也是0。还能用整除符号定义某一类型数字，比如2|a对于所有偶数a都成立，6|n(n+1)(n+2)对于任何整数n都成立。这个似乎不是特别明显，但是仔细一想，n，n+1表示了两个相邻的数字，因此两者中必有一个是2的倍数，乘积自然也是2的倍数。同理，n,n+1,n+2表示了3个相邻的数据，类似地乘积必然是3的倍数。这个数既是2的倍数，也是3的倍数，2和3互质，故这个数也是6的倍数。虽然教授还没有讲这条定理，但相信大家不难看出这层关系。

有点感觉了？来试试证明这个：$8|n^2-1$。首先我们先代入几个数字，这也是数论中很重要的一部分—防止自己脑抽。代入0，1，2都成立，可以开始证明了。按照整除的定义，我们可以考虑把$n^2-1$写成8x的形式来证明。原式想破脑袋都不可能拆出8来，于是我们从题目条件入手：n为奇数。怎么表达一个奇数？2m+1。现在代入事情就变得有点微妙了。$(2m+1)^2-1=4m^2+4m+1-1=4(m^2+m)$。可以啊，这回是4的倍数了，能不能说完成了一半了呢？再仔细看括号里的式子，有点眼熟，因数分解得m(m+1)。这是偶数，刚刚见过了。至此我们证明了原式是4和2的倍数，可惜不能直接说是8的倍数，因为两者不互质。如果我们再变形一下式子呢？$8\frac{m^2+m}{2}$,这不就是8的倍数了吗？而且由于$m^2+m$是偶数，其除以2一定是整数。证明完成。

顺便了解一个关于正整数中理想数集（idea of Z）的定义。满足d｜x的所有x的集合被称为自然数的理想数集，在加法和减法下闭合。毋庸置疑，如果两个数都整除d，那相加相减后也会整除d，毕竟不可能突然冒出来个余数。

在我们了解欧拉除法（Elucid's division algorithm)前，我们需要理解一个理想数集的定理：假设I是一个理想数集，则I=某个d的所有倍数的集合（d来自定义的d｜x）。听起来有点废话，大多数人的直觉都能感知这一点。然而还是要实实在在证明一下的。首先我们需要一个前提，I中必须有大于0的元素。否则I=｛0｝，没有意思啊。接下来找到I中最小的正整数元素a，和任意一个不相同元素b。假设两者不是倍数关系，相除会得到b=aq+r，数论中除法的常见表示。根据除法的定义，余数r一定大于等于0，小于a。接着做个变形，r=b-aq。现在你看出来了吗？I根据理想数集的定义在减法下闭合，所以b-aq在I中，进而r也在I中。变形这步就是为了证明r在I中，因为这样我们就能发现一个矛盾点：r在I中，r小于a，但是我们已经假设a是I中最小的了。只有一种可能—r等于0，则a和b是倍数关系，证明原定理成立。

中场休息时间，最大公因数的定义是什么？这里就不写了，小学玩意大家都会。仔细想想，最大公因数的定义有没有不严谨的地方？比如a和b都是0？这种情况下没有概念上的最大公因数，因为任意数都整除于0。数学家们只好规定特殊情况：gcd(0,0)=0。还是不够，因为其中一个是0又是死胡同了。再加一条，gcd(0,a)=a,就算a等于0时同样成立。


## Divisibility and Euclid's algorithms

定义a|b为a整除于b，或者说b=xa，对于某些整数x。根据这个特性，a|0是板上钉钉的事，但是0|a是不可能的，除非a也是0。还能用整除符号定义某一类型数字，比如2|a对于所有偶数a都成立，6|n(n+1)(n+2)对于任何整数n都成立。这个似乎不是特别明显，但是仔细一想，n，n+1表示了两个相邻的数字，因此两者中必有一个是2的倍数，乘积自然也是2的倍数。同理，n,n+1,n+2表示了3个相邻的数据，类似地乘积必然是3的倍数。这个数既是2的倍数，也是3的倍数，2和3互质，故这个数也是6的倍数。虽然教授还没有讲这条定理，但相信大家不难看出这层关系。

有点感觉了？来试试证明这个：$8|n^2-1$。首先我们先代入几个数字，这也是数论中很重要的一部分—防止自己脑抽。代入0，1，2都成立，可以开始证明了。按照整除的定义，我们可以考虑把$n^2-1$写成8x的形式来证明。原式想破脑袋都不可能拆出8来，于是我们从题目条件入手：n为奇数。怎么表达一个奇数？2m+1。现在代入事情就变得有点微妙了。$(2m+1)^2-1=4m^2+4m+1-1=4(m^2+m)$。可以啊，这回是4的倍数了，能不能说完成了一半了呢？再仔细看括号里的式子，有点眼熟，因数分解得m(m+1)。这是偶数，刚刚见过了。至此我们证明了原式是4和2的倍数，可惜不能直接说是8的倍数，因为两者不互质。如果我们再变形一下式子呢？$8\frac{m^2+m}{2}$,这不就是8的倍数了吗？而且由于$m^2+m$是偶数，其除以2一定是整数。证明完成。

顺便了解一个关于正整数中理想数集（idea of Z）的定义。满足d｜x的所有x的集合被称为自然数的理想数集，在加法和减法下闭合。毋庸置疑，如果两个数都整除d，那相加相减后也会整除d，毕竟不可能突然冒出来个余数。

在我们了解欧拉除法（Elucid's division algorithm)前，我们需要理解一个理想数集的定理：假设I是一个理想数集，则I=某个d的所有倍数的集合（d来自定义的d｜x）。听起来有点废话，大多数人的直觉都能感知这一点。然而还是要实实在在证明一下的。首先我们需要一个前提，I中必须有大于0的元素。否则I=｛0｝，没有意思啊。接下来找到I中最小的正整数元素a，和任意一个不相同元素b。假设两者不是倍数关系，相除会得到b=aq+r，数论中除法的常见表示。根据除法的定义，余数r一定大于等于0，小于a。接着做个变形，r=b-aq。现在你看出来了吗？I根据理想数集的定义在减法下闭合，所以b-aq在I中，进而r也在I中。变形这步就是为了证明r在I中，因为这样我们就能发现一个矛盾点：r在I中，r小于a，但是我们已经假设a是I中最小的了。只有一种可能—r等于0，则a和b是倍数关系，证明原定理成立。

中场休息时间，最大公因数的定义是什么？这里就不写了，小学玩意大家都会。仔细想想，最大公因数的定义有没有不严谨的地方？比如a和b都是0？这种情况下没有概念上的最大公因数，因为任意数都整除于0。数学家们只好规定特殊情况：gcd(0,0)=0。还是不够，因为其中一个是0又是死胡同了。再加一条，gcd(0,a)=a,就算a等于0时同样成立。

下一个问题是如何找到最大公因数gcd(a,b)？笨方法：枚举1，2，3...a，找到最大整除于b的数。绝对有用，但是这也太慢了，假如a和b都有上百位呢？这么找下来都能到宇宙的尽头了。小学教了另一种方法，将a，b分解为质数乘积，后面干啥肯定都懂了吧。这个方法比上一个简单多了，然而分解这件事本身就很难，到几百位数字的情况后效率也不高。我们要找的高效方法就是大名鼎鼎的欧拉辗转相除法（Euclid‘s algorithm）。

尝试找gcd（78，14）：

78=14\*5+8<Br>
14=8\*1+6<br>
8=6\*1+2<br>
6=2*3

那么最大公因数就是2。不难看出我们先用78/14，然后除数除以余数，循环往复，直到没有余数时，那一项的除数就是最大公因数。为什么这样可以找到gcd呢？要知道gcd（78，14）等同于gcd（14，8），因为8=78-14k，我们从原来的大数78减去14的倍数，这样肯定不会改变gcd。gcd（14，8）又等于gcd（8，6），一个道理。化简到最后等于gcd（2，0），根据之前的定理，便得到2。此算法可以保证给出一个结果，因为每次相除得到的余数都在递减，归功于每次被除数都在减小，而余数不能超过被除数。

那么辗转相除法到底有多快？嘴上说说而已吗？我们应该考虑该算法的最差情况用时。最差情况下gcd（a，b）每次得到的都是a=1\*b+r，即商次次都是1，这样我们往下递减的速度是最慢的。这类数有8和13，可以感受一下递减的速度。每次得到的余数为$r_1,r_2,r_3;r_i=r_{i+1}+r_{i+2}$。有点熟悉，如果一时间想不起来就把满足这个条件的数列写出来：0，1，1，2，3，5，8，13，21，34...，$F_n=F_{n-1}+F_{n-2}$，著名的斐波那契数列。它的上限是$2^n$，数列里每一项数字都小于或者等于$2^n$数列里的内容；下限是$2^{\frac{n}{2}}$，数列里每一项数字都大于或者等于$2^{\frac{n}{2}}$数列里的内容。记为$2^\frac{n}{2}<F_n<2^n$。辗转相除法所需要的步骤n约等于某个常数项\*log $F_n$，记为# steps of Euclid $\leq$ const*log n=const * #digits。

斐波那契数列这么有名，你知道它的通用公式吗？复习每一项的递归定义：$F_n=F_{n-1}+F_{n-2},F_0=0,F_1=1$。这其实是[有限差分](https://baike.baidu.com/item/%E6%9C%89%E9%99%90%E5%B7%AE%E5%88%86/2768735)的一个例子，和有限微分方程很像，除了这里是整数而不是实数。具有常数系数的一般有限差分方程看起来像$F_n=a_1F_{n-1}+a_2F_{n-2}+a_3F_{n-3}$,$a_1,a_2,a_3$都是常数。解这类型方程的通用办法就是“猜答案”。“猜”这个动词完全体现不出我们的水平，于是我们换一个动词——ansate。确实太高级了我甚至都找不到翻译。ansate其实表示的也是猜测，但这回是利用一些未知系数来猜测答案的形式。什么叫猜测答案的形式？有很多种办法，比如取$n^\lambda$（我不是很懂教授这里用lambda作为指数是否有什么特殊意义）。写得更详细一点就是$a_{\lambda}n^\lambda+a_{\lambda-1}n^{\lambda-1}...$。把$\lambda$看作实数，我们就有了几个未知系数$\lambda,a_\lambda,a_{\lambda-1}...$。现在要做的就是调整这个式子让其能给出答案。顺便提一下解方程的通用思路，如果你有任何方程，例如微分方程或者差分方程，第一个要做的只是尝试一些简单的可能解，比如$n^\lambda$这类的。而对于差分方程，$\lambda^n$非常有效，问题转化为$\lambda$的什么值让式子有效。

原方程是$F_n=F_{n-1}+F_{n-2}$，改成$F_n=\lambda^n$。这意味着$\lambda^n=\lambda^{n-1}+\lambda^{n-2}$。整体除以$\lambda^{n-2}$，得到$\lambda^2=\lambda+1$。就把$\lambda$当成跟x一样的普通未知数来解，用求根公式得到$\lambda=(\frac{1\pm \sqrt{5}}{2})$。这个答案怎么看起来怪怪的，确定这玩意的n次方是个整数？n=2时就已经不成立了。都到这了可不能放弃，我们对两个得到的答案进行[线性组合](https://zh.m.wikipedia.org/zh-cn/%E7%BA%BF%E6%80%A7%E7%BB%84%E5%90%88)，$a(\frac{1+\sqrt{5}}{2})^n+b(\frac{1-\sqrt{5}}{2})^n$，调整a，b的值尝试得到斐波那契数。那就从最简单的已知情况开始，$F_0=0$，这时a+b=0；$F_1=1$，这时$a\frac{1+\sqrt{5}}{2}+b\frac{1-\sqrt{5}}{2}=1$。解这个二元一次方程，得到$\sqrt{5}a=1,b=-a$。获得公式$F_n=\frac{1}{\sqrt{5}}((\frac{1+\sqrt{5}}{2})^n-(\frac{1-\sqrt{5}}{2})^n)$。有趣的地方在于斐波那契数列都是整数，然而它的公式和整数八杆子打不着。

斐波那契额数列有很多有趣的特性。1，1，2，3，5，8，交替取$5{F_n}^2\pm 4$：

$5*1^2+4=9$<br>
$5*2^2-4=16$<br>
$5*3^2+4=49$<br>
$5*4^2-4=121$

发现它们都是平方数。还有一个，取间隔数的乘积：

$1*3=3$<Br>
$2*5=10$<Br>
$3*8=24$<Br>
$5*13=65$

都和中间夹着的那个数的平方相差一。用数学语言表达就是${F_n}^2=F_{n-1}F_{n+1}\pm 1$。斐波那契数列还有很多有趣的特性，证明都不难，就当家庭作业了。