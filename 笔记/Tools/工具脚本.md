# 工具脚本

有时候一个知道的知识点却不记得解题脚本放哪个wp里了，又懒得再写一遍。那就专门开个地方存起来。分类就不分了，有些脚本多个分区都能用。

## Base64隐写

[来源](https://zhuanlan.zhihu.com/p/349481870)

```python
import base64

def Base64Stego_Decrypt(LineList):
    Base64Char = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"     #Base64字符集 已按照规范排列
    BinaryText = ""
    for line in LineList:
        if line.find("==") > 0:     #如果文本中有2个=符号
            temp = bin(Base64Char.find(line[-3]) & 15)[2:]      #通过按位与&15运算取出二进制数后4位 [2:]的作用是将0b过滤掉
            BinaryText = BinaryText+"0"*(4-len(temp))+temp      #高位补0
        elif line.find("=") > 0:        #如果文本中有1个=符号
            temp = bin(Base64Char.find(line[-2]) & 3)[2:]       #通过按位与&3运算取出二进制数后2位
            BinaryText = BinaryText+"0"*(2-len(temp))+temp      #高位补0
    Text = ""
    if(len(BinaryText) % 8 != 0):       #最终得到的隐写数据二进制位数不一定都是8的倍数，为了避免数组越界，加上一个判断
        print("警告:二进制文本位数有误，将进行不完整解析。")
        for i in range(0, len(BinaryText), 8):
            if(i+8 > len(BinaryText)):
                Text = Text+"-"+BinaryText[i:]
                return Text
            else:
                Text = Text+chr(int(BinaryText[i:i+8], 2))
    else:
        for i in range(0, len(BinaryText), 8):
            Text = Text+chr(int(BinaryText[i:i+8], 2))      #将得到的二进制数每8位一组对照ASCII码转化字符
        return Text

def Base64_ForString_Decrypt(Text):     #Base64解密
    try:
        DecryptedText = str(Text).encode("utf-8")
        DecryptedText = base64.b64decode(DecryptedText)
        DecryptedText = DecryptedText.decode("utf-8")
    except:
        return 0
    return DecryptedText

if __name__ == "__main__":
    Course = input("文件名:")
    File = open(Course, "r")
    LineList = File.read().splitlines()
    print("显式内容为:")
    for line in LineList:
        print(Base64_ForString_Decrypt(line),end="")
    print("\n隐写内容为:")
    print(Base64Stego_Decrypt(LineList))
```

## Clemency

Clemency是在DEFCON CTF中由LegitBS发明的架构（好家伙出个题直接创造了一个架构）。原生ida不支持此架构，下方链接提供了大佬的插件脚本。

[地址](https://github.com/cseagle/ida_clemency)

## 提取图片内像素并异或取值

[来源](https://blog.wujiaxing.cn/2019/09/25/e4a0a49e/)。第一次在[Blocks](https://github.com/C0nstellati0n/NoobCTF/blob/main/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/8%E7%BA%A7/Misc/Blocks.md)中使用该脚本。

```python
from PIL import Image

img = Image.open('stego_100_f78a3acde659adf7ceef546380e49e5f.png')
m1 = m2 = ''
# 取大图二进制
for y in range(0, img.size[0], 19):
    for x in range(0, img.size[1], 19):
        r,g,b,a = img.getpixel((x,y))
        m1 += str(r & 1)
# 取中间隐写图二进制
for y in range(171, 171 + 19):
    for x in range(171, 171 + 19):
        r,g,b,a = img.getpixel((x,y))
        m2 += str(a & 1)
# 二进制串取异或
xor = ''.join(str(int(A)^int(B)) for A,B in zip(m1,m2))
# 二进制转字符串并输出
print(''.join(chr(int(xor[i:i+8], 2)) for i in range(0, len(xor), 8)))
```

## 词频统计

如果是字频，也就是单纯英文字母的话，直接上[网站](https://quipqiup.com/)就行了。然而如果是统计单词出现的次数就比较麻烦了，需要自己构建字典。比如这道题：[浪里淘沙](https://www.cnblogs.com/Konmu/p/12527029.html)。

```python
f=open("浪里淘沙.txt",'r')
data=f.read()
f.close()
statistics={}
frequency=[]
num=[4,8,11,15,16]
def zipin(lsit):
    for i in lsit:
        statistics.setdefault(data.count(i),str(i))
        frequency.append(data.count(i))
    frequency.sort()
    for i in num:
        print(''.join(statistics.get(frequency[i-1])),end='')
    print('\n')
    return(statistics)

letters=["tonight","success","notice","example","should","crypto","backspace","learn","found","morning","we","system","sublim","the","user","enter"]
print(zipin(letters))
```

此题flag:`flag{weshouldlearnthecrypto}`

## xxtea

解密与加密脚本的python实现。[来源](https://www.cnblogs.com/DirWang/p/12198526.html)。

```python
import struct

_DELTA = 0x9E3779B9


def _long2str(v, w):
    n = (len(v) - 1) << 2
    if w:
        m = v[-1]
        if (m < n - 3) or (m > n): return ''
        n = m
    s = struct.pack('<%iL' % len(v), *v)
    return s[0:n] if w else s


def _str2long(s, w):
    n = len(s)
    m = (4 - (n & 3) & 3) + n
    s = s.ljust(m, b"\0")
    v = list(struct.unpack('<%iL' % (m >> 2), s))
    if w: v.append(n)
    return v


def encrypt(str, key):
    if str == '': return str
    v = _str2long(str, True)
    k = _str2long(key.ljust(16, b"\0"), False)
    n = len(v) - 1
    z = v[n]
    y = v[0]
    sum = 0
    q = 6 + 52 // (n + 1)
    while q > 0:
        sum = (sum + _DELTA) & 0xffffffff
        e = sum >> 2 & 3
        for p in  range(n):
            y = v[p + 1]
            v[p] = (v[p] + ((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4) ^ (sum ^ y) + (k[p & 3 ^ e] ^ z))) & 0xffffffff
            z = v[p]
        y = v[0]
        v[n] = (v[n] + ((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4) ^ (sum ^ y) + (k[n & 3 ^ e] ^ z))) & 0xffffffff
        z = v[n]
        q -= 1
    return _long2str(v, False)


def decrypt(str, key):
    if str == '': return str
    v = _str2long(str, False)
    k = _str2long(key.ljust(16, b"\0"), False)
    n = len(v) - 1
    z = v[n]
    y = v[0]
    q = 6 + 52 // (n + 1)
    sum = (q * _DELTA) & 0xffffffff
    while (sum != 0):
        e = sum >> 2 & 3
        for p in range(n, 0, -1):
            z = v[p - 1]
            v[p] = (v[p] - ((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4) ^ (sum ^ y) + (k[p & 3 ^ e] ^ z))) & 0xffffffff
            y = v[p]
        z = v[n]
        v[0] = (v[0] - ((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4) ^ (sum ^ y) + (k[0 & 3 ^ e] ^ z))) & 0xffffffff
        y = v[0]
        sum = (sum - _DELTA) & 0xffffffff
    return _long2str(v, True)
```

## openssl解密rsa

- openssl rsautl -decrypt -inkey privatekey.key -in cipher.enc -out result

## openssl私钥格式

头和尾分别需要包含这两行：

```
-----BEGIN RSA PRIVATE KEY-----
-----END RSA PRIVATE KEY-----
```

## 批量openssl解密并合并图片

例题：[Mysterious-GIF](https://github.com/C0nstellati0n/NoobCTF/blob/main/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/6%E7%BA%A7/Misc/Mysterious-GIF.md)

## uncompyle6反编译pyc

- uncompyle6 -o result.py ctf.pyc

## 读取两个文件内容并xor

要求两个文件内容长度一致。

```python
from Crypto.Util.strxor import strxor
with open("a.txt") as f:
    data1=f.read()
with open("b.txt") as f:
    data2=f.read()
print(strxor(data1.encode(),data2.encode()))
```

## 简单z3使用

z3默认只会给出一个解，如果想要全部的解可以像下面这样：

```python
from z3 import *
x=Int('x')
solver=Solver()
solver.add(x*(x+1)-7943722218936282==0)
solutions=[]
while solver.check():
    print(solver.model())
```

然而它无法自己停下来，需要手动ctrl+c。例题1:[EquationPy](https://github.com/C0nstellati0n/NoobCTF/blob/main/CTF/moectf/Reverse/EquationPy.md)。例题2:[ezhash](https://github.com/C0nstellati0n/NoobCTF/blob/main/CTF/moectf/Crypto/ezhash.md)

## python3实现换表base64解密

此脚本为题目[easyjni](https://adworld.xctf.org.cn/challenges/details?hash=ebe1d9bb-662e-4922-a257-828d58e2a4aa_2&task_category_id=6)的解题脚本。

```python
from base64 import b64decode
data=list('MbT3sQgX039i3g==AQOoMQFPskB1Bsc7')
index=0
for i in range(0,len(data),2):
	data[i],data[i+1]=data[i+1],data[i]
flag=''.join(data[16:]+data[:16])
STANDARD_ALPHABET = b'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
CUSTOM_ALPHABET = b'i5jLW7S0GX6uf1cv3ny4q8es2Q+bdkYgKOIT/tAxUrFlVPzhmow9BHCMDpEaJRZN'
DECODE_TRANS = bytes.maketrans(CUSTOM_ALPHABET, STANDARD_ALPHABET)
print(b64decode(flag.translate(DECODE_TRANS)))
```

换表后题目给出的字符不全就要用itertools爆破，比如：

```python
from base64 import b64decode
import itertools
cipher=b'MyLkTaP3FaA7KOWjTmKkVjWjVzKjdeNvTnAjoH9iZOIvTeHbvD=='
STANDARD_ALPHABET = b'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for i in itertools.permutations(b"ju34",4):
    s=''.join([chr(j) for j in i])
    CUSTOM_ALPHABET = b'JASGBWcQPRXEFLbCDIlmnHUVKTYZdMovwipatNOefghq56rs'+s.encode()+b'kxyz012789+/'
    DECODE_TRANS = bytes.maketrans(CUSTOM_ALPHABET, STANDARD_ALPHABET)
    print(b64decode(cipher.translate(DECODE_TRANS)))
```

例题：[[WUSTCTF2020]B@se](https://buuoj.cn/challenges#[WUSTCTF2020]B@se)

## python爆破sha1值

[来源](https://blog.csdn.net/qq_42967398/article/details/96492843)

```python
import hashlib

flag = "@DBApp"

for i in range(100000,999999):
	s = str(i)+flag
	x = hashlib.sha1(s.encode())
	cnt = x.hexdigest()
	if "6e32d0943418c2c" in cnt:
		print(cnt)
		print(str(i)+flag)
```

## 常见文件文件头

[链接](https://www.cnblogs.com/gwind/p/8215771.html)

## C语言格式化字符串参考

[链接](https://blog.csdn.net/chenmozhe22/article/details/109738852)